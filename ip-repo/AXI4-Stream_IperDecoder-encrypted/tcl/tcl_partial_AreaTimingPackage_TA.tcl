#============================= SYNTH ANALISYS DEEFINE ==========================
# Range of Generics
set	MIN_NUMBER_OF_INPUT	2
set	MAX_NUMBER_OF_INPUT	16

set	MIN_INPUT_ENGINE	2
set	MAX_INPUT_ENGINE	4

set	MIN_BIT_INPUT	1
set	MAX_BIT_INPUT	12

# Regenerate Run Option
set REGENERATE_RUN	0

#===============================================================================


#============================== THIS PACKAGE DEFINE ============================

#-------------------------------- Name/Location ---------------------------------
set package_location	"/home/nicola/Documents/Vivado/Utility_Ip_Core/ip_repo/TDC_Basic_IPs/tree-adder/hdl"
set package_name		"partial_AreaTimingPackage_TA"
#-------------------------------------------------------------------------------

#------------------------------- Status/Location -------------------------------
set status_location	"/home/nicola/Documents/Vivado/Utility_Ip_Core/ip_repo/TDC_Basic_IPs/tree-adder/txt"
set status_name		"status_tcl_partial_AreaTimingPackage_TA"
#-------------------------------------------------------------------------------

#--------------------------------- Description ---------------------------------
set		description	"-------------------------------------DESCRIPTION----------------------------------------\n"
append	description	"----------------------------------------------------------------------------------------\n"
append	description	"--								  Autogenerated Package  							   --\n"
append	description	"--	                Area Occupacy and Post-Synth Timing Analisis From TreeAdder        --\n"
append	description	"--			PARTIAL CONFIGUARTION (NOT SET MAX_INPUT_ENGINE_PIPELINE_STAGE 2 and 3)    --\n"
append	description	"----------------------------------------------------------------------------------------\n"
append	description	"----------------------------------------------------------------------------------------\n"

#-------------------------------------------------------------------------------

#===============================================================================



#============================== ALL PACKAGEs DEFINE ============================

#----------------------------------- Header ------------------------------------
set		header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"----  *   )                                                                                  ----\n"
append	header_1	"----` )  /( (      )      (    (           (  (  (            (    (   (   (          (  (   ----\n"
append	header_1	"---- ( )(_)))\\    (      ))\\   )\\    (     )\\))( )\\   (      ))\\  ))\\  )(  )\\   (     )\\))(  ----\n"
append	header_1	"----(_(_())((_)   )\\  ' /((_) ((_)   )\\ ) ((_))\\((_)  )\\ )  /((_)/((_)(()\\((_)  )\\ ) ((_))\\  ----\n"
append	header_1	"----|_   _| (_) _((_)) (_))   | __| _(_/(  (()(_)(_) _(_/( (_)) (_))   ((_)(_) _(_/(  (()(_) ----\n"
append	header_1	"----  | |   | || '  \\()/ -_)  | _| | ' \\))/ _` | | || ' \\))/ -_)/ -_) | '_|| || ' \\))/ _` |  ----\n"
append	header_1	"----  |_|   |_||_|_|_| \\___|  |___||_||_| \\__, | |_||_||_| \\___|\\___| |_|  |_||_||_| \\__, |  ----\n"
append	header_1	"----                                      |___/                                      |___/   ----\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"


set		header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"----           _____     _                      ___             __ _     _                                       _              __ _  ----\n"
append	header_2	"----    o O O |_   _|   (_)    _ __     ___    | __|   _ _     / _` |   (_)    _ _      ___     ___      _ _    (_)    _ _     / _` | ----\n"
append	header_2	"----   o        | |     | |   | '  \\   / -_)   | _|   | ' \\    \\__, |   | |   | ' \\    / -_)   / -_)    | '_|   | |   | ' \\    \\__, | ----\n"
append	header_2	"----  TS__\[O\]  _|_|_   _|_|_  |_|_|_|  \\___|   |___|  |_||_|   |___/   _|_|_  |_||_|   \\___|   \\___|   _|_|_   _|_|_  |_||_|   |___/  ----\n"
append	header_2	"---- {======|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"| ----\n"
append	header_2	"----./o--000'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-' ----\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"

#-------------------------------------------------------------------------------


#------------------------------ Libraty ----------------------------------------
set		default_library	"---------- DEFAULT LIBRARY ---------\n"
append	default_library	"library IEEE;\n"
append	default_library	"\tuse IEEE.STD_LOGIC_1164.all;\n"
append	default_library	"\tuse IEEE.NUMERIC_STD.ALL;\n"
append	default_library	"\t--use IEEE.MATH_REAL.all;\n"
append	default_library	"------------------------------------\n"

set		others_library	"---------- OTHERS LIBRARY ----------\n"
append	others_library	"-- NONE\n"
append	others_library	"------------------------------------\n"
#-------------------------------------------------------------------------------

#===============================================================================





#============================== ALL PACKAGES PROC ==============================

#------------------------------- Generate Package ------------------------------

proc generate_package {package_name constants_def types_def constants_init}\
{
	set		package	"package "
	append	package	$package_name
	append	package	" is\n"

	append	package	"\n"
	append	package	"\t--------------------------- Constants ----------------------------\n"
	append	package	"\n"
	append	package	$constants_def
	append	package	"\n"
	append	package	"\t-----------------------------------------------------------------\n"
	append	package	"\n"

	append	package	"\n"
	append	package	"\t---------------------------- Types Def ----------------------------\n"
	append	package	"\n"
	append	package	$types_def
	append	package	"\n"
	append	package	"\t-----------------------------------------------------------------\n"
	append	package	"\n"

	append	package	"\n"
	append	package	"\t---------------------------- Function ---------------------------\n"
	append	package	"\n"
	append	package	"\t------ Function Definition ----\n"
	append	package	"\t-- NONE\n"
	append	package	"\t-------------------------------\n"
	append	package	"\n"
	append	package	"\t-----------------------------------------------------------------\n"
	append	package	"\n"

	append	package	"\n"
	append	package	"\t-------------------- Autocomputed Constants ---------------------\n"
	append	package	"\n"
	append	package	$constants_init
	append	package	"\n"
	append	package	"\t-----------------------------------------------------------------\n"

	append	package	"end\t"
	append	package	$package_name
	append	package	";\n\n"

	return $package
}
#-------------------------------------------------------------------------------

#-------------------------------- Generate Body --------------------------------
proc generate_body {package_name}\
{
	set		body	"package body "
	append	body	$package_name
	append	body	" is\n"
	append	body	"\n"
	append	body	"\t---------------------------- Function ---------------------------\n"
	append	body	"\n"
	append	body	"\t------ Function Definition ----\n"
	append	body	"\t-- NONE\n"
	append	body	"\t-------------------------------\n"
	append	body	"\n"
	append	body	"\t-----------------------------------------------------------------\n"
	append	package	"\n"
	append	body	"end\t"
	append	body	$package_name
	append	body	";\n\n"

	return $body
}
#-------------------------------------------------------------------------------



#===============================================================================


#============================== THIS PACKAGE PROC ==============================

#------------------------- Generate AREA_TIMING_RECORD_TYPE -------------------
proc generate_constant_def {MIN_NUMBER_OF_INPUT MAX_NUMBER_OF_INPUT MIN_INPUT_ENGINE MAX_INPUT_ENGINE MIN_BIT_INPUT MAX_BIT_INPUT} \
{

	set		constant_def "\t--- Range of Number of Input ---\n"
	append	constant_def "\tconstant\tMIN_NUMBER_OF_INPUT\t:\tPOSITIVE\t:=\t$MIN_NUMBER_OF_INPUT;\n"
	append	constant_def "\tconstant\tMAX_NUMBER_OF_INPUT\t:\tPOSITIVE\t:=\t$MAX_NUMBER_OF_INPUT;\n"
	append	constant_def "\t-------------------------------\n"
	append	constant_def "\n"

	append	constant_def "\t---- Range of Max In Engine ---\n"
	append	constant_def "\tconstant\tMIN_INPUT_ENGINE\t:\tPOSITIVE\t:=\t$MIN_INPUT_ENGINE;\n"
	append	constant_def "\tconstant\tMAX_INPUT_ENGINE\t:\tPOSITIVE\t:=\t$MAX_INPUT_ENGINE;\n"
	append	constant_def "\t-------------------------------\n"
	append	constant_def "\n"

	append	constant_def "\t-- Range of Bit In, Max In Val -\n"
	append	constant_def "\tconstant\tMIN_BIT_INPUT\t:\tPOSITIVE\t:=\t$MIN_BIT_INPUT;\n"
	append	constant_def "\tconstant\tMAX_BIT_INPUT\t:\tPOSITIVE\t:=\t$MAX_BIT_INPUT;\n"
	append	constant_def "\t-------------------------------\n"
	append	constant_def "\n"

	return $constant_def
}
#-------------------------------------------------------------------------------

#------------------------- Generate AREA_TIMING_RECORD_TYPE -------------------
proc generate_record_def {} \
{

	set		record_def "\t-- Area and Timing Report --\n"
	append	record_def "\ttype\tAREA_TIMING_RECORD_TYPE\tis\trecord\n"
	append	record_def "\t\t--- Occuped Area ---\n"
	append	record_def "\t\tLUTs\t:\tNATURAL;\t-- Numbers of Total LUTs required\n"
	append	record_def "\t\tFFs\t\t:\tNATURAL;\t-- Numbers of Total FFs required\n"
	append	record_def "\t\t--------------------\n"
	append	record_def "\n"
	append	record_def "\t\t------- Timing ------\n"
	append	record_def "\t\tDELAY\t:\tNATURAL;\t-- Maximum Async Propagation Logic Delay espressed as min Async Propagation Logic Delay avaiable\n"
	append	record_def "\t\t--------------------\n"
	append	record_def "\tend\trecord\tAREA_TIMING_RECORD_TYPE;\n"
	append	record_def "\t----------------------------\n"

	return $record_def
}
#-------------------------------------------------------------------------------

#---------------------- Generate AREA_TIMING_ARRAY_RECORD_TYPE -----------------
proc generate_array_record_def {free_running_range number_of_input_range max_input_engine_range bit_input_range} \
{
	set		array_record_def	"\t-- Area and Timing Array --\n"
	append	array_record_def	"\ttype\tAREA_TIMING_ARRAY_RECORD_TYPE\tis\tarray\t"
	append	array_record_def 	"([lindex $free_running_range 0] to [lindex $free_running_range 1],\t"
	append	array_record_def 	"[lindex $number_of_input_range 0] to [lindex $number_of_input_range 1],\t"
	append	array_record_def 	"[lindex $max_input_engine_range 0] to [lindex $max_input_engine_range 1],\t"
	append	array_record_def 	"[lindex $max_input_engine_range 0] to [lindex $max_input_engine_range 1],\t"
	append	array_record_def 	"[lindex $bit_input_range 0] to [lindex $bit_input_range 1])\t"
	append	array_record_def	"of AREA_TIMING_RECORD_TYPE;\n"
	append	array_record_def 	"\t--------------------\n"

	return $array_record_def
}
#-------------------------------------------------------------------------------


#---------------------- Generate constant AREA_TIMIMNG_USAGE -------------------
proc generate_constant_array_record {free_running_range number_of_input_range max_input_engine_range bit_input_range results_list} \
{
	# Transform list results_list in array result
	array set results {}
	unset results

	set i 0

	for {set free_running [lindex $free_running_range 0]} {$free_running <= [lindex $free_running_range 1]} {incr free_running} {
		for	{set number_of_input [lindex $number_of_input_range 0]} {$number_of_input <= [lindex $number_of_input_range 1]} {incr number_of_input}	{

			for {set max_input_engine_0 [lindex $max_input_engine_range 0]} {$max_input_engine_0 <= [lindex $max_input_engine_range 1]} {incr max_input_engine_0} {
				for {set max_input_engine_1 [lindex $max_input_engine_range 0]} {$max_input_engine_1 <= [lindex $max_input_engine_range 1]} {incr max_input_engine_1} {


					for	{set bit_input [lindex $bit_input_range 0]} {$bit_input <= [lindex $bit_input_range 1]} {incr bit_input}	{

						set results([list $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $bit_input]) [lindex $results_list $i]
						incr i

					}


				}
			}

		}
	}


	set constant_array_record "\tconstant\tAREA_TIMING_USAGE\t:\tAREA_TIMING_ARRAY_RECORD_TYPE\t:=\n"

	append constant_array_record "\t(\n"

	for {set free_running [lindex $free_running_range 0] } {$free_running <= [lindex $free_running_range 1] } {incr free_running} {

		set free_running_boole	"FALSE"
		if {$free_running == [lindex $free_running_range 1]} { set free_running_boole	"TRUE" }

		append constant_array_record "\t\t(\n"

		for {set number_of_input [lindex $number_of_input_range 0]} {$number_of_input <= [lindex $number_of_input_range 1]} {incr number_of_input} {

			append constant_array_record "\t\t\t(\n"

			for {set max_input_engine_0 [lindex $max_input_engine_range 0]} {$max_input_engine_0 <= [lindex $max_input_engine_range 1]} {incr max_input_engine_0} {

				append constant_array_record "\t\t\t\t(\n"

				for {set max_input_engine_1 [lindex $max_input_engine_range 0]} {$max_input_engine_1 <= [lindex $max_input_engine_range 1]} {incr max_input_engine_1} {

					append constant_array_record "\t\t\t\t\t(\n"


					for	{set bit_input [lindex $bit_input_range 0]} {$bit_input <= [lindex $bit_input_range 1]}	{incr bit_input}	{


						set tmp $results([list $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $bit_input])


						set luts	[lindex $tmp 0]
						set ffs		[lindex $tmp 1]
						set delay	[lindex $tmp 2]

						append constant_array_record "\t\t\t\t\t\t"
						append constant_array_record "("
						append constant_array_record $luts
						append constant_array_record ","
						append constant_array_record $ffs
						append constant_array_record ","
						append constant_array_record $delay
						append constant_array_record ")"

						if {$bit_input < [lindex $bit_input_range 1]} {
							append constant_array_record ","
						}

						append constant_array_record "\t--FREE_RUNNING = $free_running_boole,\tNUMBER_OF_INPUT = $number_of_input,"
						append constant_array_record "\tMAX_INPUT_ENGINE_0 = $max_input_engine_0,\tMAX_INPUT_ENGINE_1 = $max_input_engine_1,"
						append constant_array_record "\tBIT_INPUT = $bit_input\n"

					}




					append constant_array_record "\t\t\t\t\t)"
					if {$max_input_engine_1 < [lindex $max_input_engine_range 1]} {
						append constant_array_record ",\n"
					} else {
						append constant_array_record "\n"
					}
				}

				append constant_array_record "\t\t\t\t)"
				if {$max_input_engine_0 < [lindex $max_input_engine_range 1]} {
					append constant_array_record ",\n"
				} else {
					append constant_array_record "\n"
				}
			}

			append constant_array_record "\t\t\t)"
			if {$number_of_input < [lindex $number_of_input_range 1]} {
				append constant_array_record ",\n"
			} else {
				append constant_array_record "\n"
			}
		}

		append constant_array_record "\t\t)"
		if {$free_running < [lindex $free_running_range 1]} {
			append constant_array_record ",\n"
		} else {
			append constant_array_record "\n"
		}
	}

	append constant_array_record "\t);\n"

	return $constant_array_record
}
#-------------------------------------------------------------------------------

#===============================================================================


#======================== SYNTH ANALISYS PROCEDURE =============================
#-- Compute the LUTs FFs maxLogicCrossed max/min PathDelay with synth_design --
proc computeRecord_synth_design {free_running number_of_input max_input_engine_0 max_input_engine_1 bit_input} \
{

	#-------------------------- Synthesis Project Mode -------------------------

	set bit_out [ expr int([expr [::tcl::mathfunc::ceil [expr [::tcl::mathfunc::log10 $number_of_input]/[::tcl::mathfunc::log10 2]]]]) + $bit_input]


	set 	generic_str "FREE_RUNNING=1'b[expr $free_running] "
	append	generic_str "MAX_INPUT_ENGINE_PIPELINE_STAGE0=[expr $max_input_engine_0] "

	append	generic_str	"MAX_INPUT_ENGINE_PIPELINE_STAGE0=[expr $max_input_engine_0] "
	append	generic_str	"MAX_INPUT_ENGINE_PIPELINE_STAGE1=[expr $max_input_engine_1] "

	append	generic_str	"NUMBER_OF_INPUT=[expr $number_of_input] "
	append	generic_str	"MAXIMUM_INPUT_VALUE=[expr 2**$bit_input -1] "

	append	generic_str	"BIT_INPUT=[expr $bit_input] "
	append	generic_str	"BIT_OUTPUT=[expr $bit_out] "

	# Set the New Generic set (for safety)
	set_property GENERIC	$generic_str	[current_fileset]


	# Open the Syntehesis for the results computation in Out Of Context withou buffers
	synth_design -mode out_of_context

	#---------------------------------------------------------------------------


	#------------------------------ Results ------------------------------------


	# Compute the Number of FFs and LUTs
	set	LUTs	[llength [get_cells -hierarchical -filter { PRIMITIVE_TYPE =~ CLB.LUT.* } ]]
	set	FFs		[llength [get_cells -hierarchical -filter { PRIMITIVE_TYPE =~ REGISTER.SDR.* } ]]

	# Initializate the Post-Synthesis timing analisys
	create_clock -period 10.000 -name clk_test_timing -waveform {0.000 5.000} [get_nets Clk]

	# Identify the max and min propagation delay in nano seconds
	set	maxPathDelayNanoSec	[get_property DATAPATH_DELAY [get_timing_paths -setup ]]
	set	minPathDelayNanoSec	[get_property DATAPATH_DELAY [get_timing_paths -hold ]]

	# Set the number of logic crossed in from a FF to a FF
	if {$minPathDelayNanoSec == 0} {
		set maxLogicCrossed 1
	} else {
		set maxLogicCrossed [expr {int([expr {ceil($maxPathDelayNanoSec/$minPathDelayNanoSec)}])}]
	}



	# Save Results
	set results_synth [list $LUTs $FFs $maxLogicCrossed $maxPathDelayNanoSec $minPathDelayNanoSec]

	# Close the Post-Syntesis
	close_design
	#--------------------------------------------------------------------------

	return $results_synth

}
#-------------------------------------------------------------------------------


#-------- Compute the LUTs FFs maxLogicCrossed max/min PathDelay in run --------

proc computeRecord_launch_run {free_running number_of_input max_input_engine_0 max_input_engine_1 bit_input regenerate_run} \
{

	set bit_out [ expr int([expr [::tcl::mathfunc::ceil [expr [::tcl::mathfunc::log10 $number_of_input]/[::tcl::mathfunc::log10 2]]]]) + $bit_input]


	set 	generic_str "FREE_RUNNING=1'b[expr $free_running] "
	append	generic_str "MAX_INPUT_ENGINE_PIPELINE_STAGE0=[expr $max_input_engine_0] "

	append	generic_str	"MAX_INPUT_ENGINE_PIPELINE_STAGE0=[expr $max_input_engine_0] "
	append	generic_str	"MAX_INPUT_ENGINE_PIPELINE_STAGE1=[expr $max_input_engine_1] "

	append	generic_str	"NUMBER_OF_INPUT=[expr $number_of_input] "
	append	generic_str	"MAXIMUM_INPUT_VALUE=[expr 2**$bit_input -1] "

	append	generic_str	"BIT_INPUT=[expr $bit_input] "
	append	generic_str	"BIT_OUTPUT=[expr $bit_out] "


	set		synth_id	"synth_FR[expr $free_running]"
	append	synth_id	"_STAGE[expr $max_input_engine_0]"
	append	synth_id	"_STAGE[expr $max_input_engine_1]"
	append	synth_id	"_NI[expr $number_of_input]"
	append	synth_id	"_BI[expr $bit_input]"
	append	synth_id	"_BO[expr $bit_out]"

	#-------------------------- Synthesis Project Mode -------------------------

	# Set the New Generic set (for safety)
	set_property GENERIC	$generic_str	[current_fileset]


	# Create and Run Specific Syntesis
	if {[get_runs $synth_id] != $synth_id} {

		# Create Synth Run
		create_run $synth_id -flow {Vivado Synthesis 2017}

		# Set the New Generic set
		set_property GENERIC	$generic_str	[current_fileset]

		# Launch the New Synthesis
		launch_runs	$synth_id	-jobs 6

		# Wait untill the Syntehesis is finished
		wait_on_run	$synth_id

	 # Open/Reset and ReRun an esisten Syntesis Rus
	} else {

		# Re Run only if request
		if { $regenerate_run == 1 } {

			# Reset Synth Run
			reset_run $synth_id

			# Set the New Generic set (for safety)
			set_property GENERIC	$generic_str	[current_fileset]

			# Launch the New Synthesis
			launch_runs	$synth_id	-jobs 6

			# Wait untill the Syntehesis is finished
			wait_on_run	$synth_id

		} else {

			open_run $synth_id -name $synth_id

		}
	}
	#---------------------------------------------------------------------------


	#------------------------------ Results ------------------------------------
	# Open the Syntehesis for the results computation in Out Of Context withou buffers
	synth_design -mode out_of_context

	# Compute the Number of FFs and LUTs
	set	LUTs	[llength [get_cells -hierarchical -filter { PRIMITIVE_TYPE =~ CLB.LUT.* } ]]
	set	FFs		[llength [get_cells -hierarchical -filter { PRIMITIVE_TYPE =~ REGISTER.SDR.* } ]]

	# Initializate the Post-Synthesis timing analisys
	create_clock -period 10.000 -name clk_test_timing -waveform {0.000 5.000} [get_nets clk]

	# Identify the max and min propagation delay in nano seconds
	set	maxPathDelayNanoSec	[get_property DATAPATH_DELAY [get_timing_paths -setup ]]
	set	minPathDelayNanoSec	[get_property DATAPATH_DELAY [get_timing_paths -hold ]]

	# Set the number of logic crossed in from a FF to a FF
	if {$minPathDelayNanoSec == 0} {
		set maxLogicCrossed 1
	} else {
		set maxLogicCrossed [expr {int([expr {ceil($maxPathDelayNanoSec/$minPathDelayNanoSec)}])}]
	}

	# Save Results
	set results_synth [list $LUTs $FFs $maxLogicCrossed $maxPathDelayNanoSec $minPathDelayNanoSec]

	# Close the Post-Syntesis
	close_design
	#--------------------------------------------------------------------------

	return $results_synth

}
#-------------------------------------------------------------------------------


#===============================================================================





#============================== USER DEFINED PROC ==============================

#------------------------------ int(ceil(a/b)) ----------------------------------

proc div_exc {a b} \
{

	set q [expr $a/$b]

	set r [expr $a%$b]

	if {$r != 0} {
		set q [expr $q+1]
	}

	return $q

}
#-------------------------------------------------------------------------------


#===============================================================================





#============================= PARTIAL SCRIPT INIT =============================

#-------------------- Filter all possible Generics beetwen ---------------------
#              NUMBER_OF_INPUT and MAX_INPUT_ENGINE_PIPELINE_STAGEs

# Array LUT that filters the set of generics in that one usefull for the hdl
array set generic_array_flt {}
array set generic_array_flt_dbg {}

unset generic_array_flt
unset generic_array_flt_dbg



# IF NUMBER_OF_INPUT < MAX_INPUT_ENGINE_PIPELINE_STAGE0
# Only one stage of pipeline set by MAX_INPUT_ENGINE_PIPELINE_STAGE0
for	{set number_of_input $MIN_NUMBER_OF_INPUT} {$number_of_input <= $MAX_NUMBER_OF_INPUT} {incr number_of_input}	{

	for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
		for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {


			# Thresfolds
			set min_number_of_input_stage_0	$max_input_engine_0
			set min_number_of_input_stage_1	[expr $max_input_engine_1*$min_number_of_input_stage_0]

			if { $number_of_input < $min_number_of_input_stage_0 & $number_of_input < $min_number_of_input_stage_1} {

				set max_input_engine_0_res $number_of_input

				if { $max_input_engine_0_res == 1} {
					set max_input_engine_0_res $MIN_INPUT_ENGINE
				}

				set generic_array_flt([list $number_of_input $max_input_engine_0 $max_input_engine_1]) [list $number_of_input $max_input_engine_0_res $MIN_INPUT_ENGINE]
				# Debug value with 0 index
				# set generic_array_flt_dbg ([list $number_of_input $max_input_engine_0 $max_input_engine_1]) [list $number_of_input $max_input_engine_0_res $MIN_INPUT_ENGINE "0"]

			}
		}
	}

}



# IF NUMBER_OF_INPUT >= MAX_INPUT_ENGINE_PIPELINE_STAGE0*MAX_INPUT_ENGINE_PIPELINE_STAGE1
# Only two stages of pipeline, fist full, set by MAX_INPUT_ENGINE_PIPELINE_STAGE0 and MAX_INPUT_ENGINE_PIPELINE_STAGE1
for	{set number_of_input $MIN_NUMBER_OF_INPUT} {$number_of_input <= $MAX_NUMBER_OF_INPUT} {incr number_of_input}	{

	for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
		for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {


			# Thresfolds
			set min_number_of_input_stage_0	$max_input_engine_0
			set min_number_of_input_stage_1	[expr $max_input_engine_1*$min_number_of_input_stage_0]

			if { $number_of_input >= $min_number_of_input_stage_0 & $number_of_input < $min_number_of_input_stage_1 } {

				set max_input_engine_1_res [div_exc $number_of_input $max_input_engine_0]

				if { $max_input_engine_1_res == 1} {
					set max_input_engine_1_res $MIN_INPUT_ENGINE
				}

				set generic_array_flt([list $number_of_input $max_input_engine_0 $max_input_engine_1]) [list $number_of_input $max_input_engine_0 $max_input_engine_1_res]
				# Debug value with 1 index
				# set generic_array_flt_dbg([list $number_of_input $max_input_engine_0 $max_input_engine_1]) [list $number_of_input $max_input_engine_0 $max_input_engine_1_res "1"]
			}


		}
	}

}


# IF NUMBER_OF_INPUT >= MAX_INPUT_ENGINE_PIPELINE_STAGE0*MAX_INPUT_ENGINE_PIPELINE_STAGE1
# Two or More stages of pipeline, all full, set by MAX_INPUT_ENGINE_PIPELINE_STAGE0 and MAX_INPUT_ENGINE_PIPELINE_STAGE1
for	{set number_of_input $MIN_NUMBER_OF_INPUT} {$number_of_input <= $MAX_NUMBER_OF_INPUT} {incr number_of_input}	{

	for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
		for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {


			# Thresfolds
			set min_number_of_input_stage_0	$max_input_engine_0
			set min_number_of_input_stage_1	[expr $max_input_engine_1*$min_number_of_input_stage_0]

			if { $number_of_input >= $min_number_of_input_stage_0 & $number_of_input >= $min_number_of_input_stage_1} {
				set generic_array_flt([list $number_of_input $max_input_engine_0 $max_input_engine_1]) [list $number_of_input $max_input_engine_0 $max_input_engine_1]

				# Debug value with 4 index
				# set generic_array_flt_dbg([list $number_of_input $max_input_engine_0 $max_input_engine_1]) [list $number_of_input $max_input_engine_0 $max_input_engine_1 "4"]
			}


		}
	}

}


#----- test ------
# parray generic_array_flt
# parray generic_array_flt_dbg
#-----------------

#-------------------------------------------------------------------------------



#---------------- Full Generics Set is TO_SYNTh or to_copy ---------------------
#								FOR DEBUGGING

# Find the results and puts in array
array set full_generic_array_flt {}
unset full_generic_array_flt


# Minimum Value
set ref [list 1 1 1]

set total_cores 0
set cores_to_synth 0
set cores_to_copy 0

for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for	{set bit_input $MIN_BIT_INPUT} {$bit_input <= $MAX_BIT_INPUT}	{incr bit_input}	{

		# Use the generics_array_flt as LUT
		for	{set number_of_input $MIN_NUMBER_OF_INPUT} {$number_of_input <= $MAX_NUMBER_OF_INPUT} {incr number_of_input}	{

			for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
				for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {


					incr total_cores
					set generics_array_flt_set	$generic_array_flt([list $number_of_input $max_input_engine_0 $max_input_engine_1 ])

					# If the generics set is new
					if { $generics_array_flt_set != $ref } {
						# Target as To Synth
						set full_generic_array_flt([list $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $bit_input])  [concat [list $free_running] $generics_array_flt_set [list $bit_input "TO_SYNTH"]]
						set ref $generics_array_flt_set
						incr cores_to_synth
					} else {
						# Target as To Copy
						set full_generic_array_flt([list $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $bit_input]) [concat [list $free_running] $generics_array_flt_set [list $bit_input "to_copy"]]
						incr cores_to_copy
					}




				}
			}

		}


	}
}

#----- test ------
# parray full_generic_array_flt
# puts $total_cores
# puts $cores_to_synth
# puts $cores_to_copy
#-----------------


#-- Write Status --

# Set status
set 	file_txt "========== PRE-ANALISYS ==========\n"
append	file_txt "Cores To Synth\t$cores_to_synth\n"
append	file_txt "Cores To Copy\t$cores_to_copy\n"
append	file_txt "Total Cores \t$total_cores\n"
append 	file_txt "==================================\n\n"

# Set path
set		status_path	$status_location
append	status_path	"/"
append	status_path	$status_name
append	status_path	".txt"

# Open file_vhd for writing
set status_outputFile [open $status_path w]

# Put some text in to the file
puts $status_outputFile $file_txt

# Close the file
close $status_outputFile
#-----------------


#-------------------------------------------------------------------------------

#===============================================================================



#=============================== PARTIAL SCRIPT ================================

#------------------ Full Generics Set  TO_SYNTh or to_copy ---------------------
#						FOR SYNTH AND ANALISYS


# Find the results and puts in array
array set results {}
unset results

set total_cores 0
set cores_to_synth 0
set cores_to_copy 0


set ref [list 1 1 1]

for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for	{set bit_input $MIN_BIT_INPUT} {$bit_input <= $MAX_BIT_INPUT}	{incr bit_input}	{

		# Use the generics_array_flt as LUT
		for	{set number_of_input $MIN_NUMBER_OF_INPUT} {$number_of_input <= $MAX_NUMBER_OF_INPUT} {incr number_of_input}	{

			for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
				for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {

					incr total_cores

					set generics_array_flt_set	$generic_array_flt([list $number_of_input $max_input_engine_0 $max_input_engine_1])

					# If the generics set is new
					if { $generics_array_flt_set != $ref } {

						# To Synth
						# set results([list $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $bit_input]) [computeRecord_launch_run $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $bit_input $REGENERATE_RUN]
						set results([list $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $bit_input]) [computeRecord_synth_design $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $bit_input]

						set ref $generics_array_flt_set
						set index [list $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $bit_input]

						incr cores_to_synth

					} else {
						# Target as To Copy
						set results([list $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $bit_input]) $results($index)

						incr cores_to_copy

					}




					#-- Write Status --
					# Open file_vhd for writing
					set status_outputFile [open $status_path w]

					# Set status
					set		file_txt_tmp $file_txt
					append 	file_txt_tmp "========== EXE-ANALISYS ==========\n"
					append 	file_txt_tmp "Synth\t$cores_to_synth\n"
					append 	file_txt_tmp "Copy\t$cores_to_copy\n"
					append 	file_txt_tmp "Total\t$total_cores\n"
					append 	file_txt_tmp "==================================\n"


					# Put some text in to the file
					puts $status_outputFile $file_txt_tmp

					# Close the file
					close $status_outputFile
					#-----------------





				}
			}

		}


	}
}




#----- test ------
# parray results
#-----------------

#-------------------------------------------------------------------------------



#--- Find the min Propagation Delay For Better Extimation of maxLogicCrossed ---

# Find the min_propagation_delay in all the synth avaiable
set min_propagation_delay_list [list]
unset min_propagation_delay_list

for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for	{set number_of_input $MIN_NUMBER_OF_INPUT} {$number_of_input <= $MAX_NUMBER_OF_INPUT} {incr number_of_input}	{

		for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
			for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {


				for	{set bit_input $MIN_BIT_INPUT} {$bit_input <= $MAX_BIT_INPUT}	{incr bit_input}	{


					set min_propagation_delay_tmp	[ lindex $results([list $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $bit_input]) 4]
					if {$min_propagation_delay_tmp > 0 } {

						lappend min_propagation_delay_list $min_propagation_delay_tmp

					}


				}


			}
		}

	}
}

# The min is the first not zero
set min_propagation_delay [lindex [ lsort $min_propagation_delay_list] 0]

# Redo the computation of the MaxLogicCrossed
for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for	{set number_of_input $MIN_NUMBER_OF_INPUT} {$number_of_input <= $MAX_NUMBER_OF_INPUT} {incr number_of_input}	{

		for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
			for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {

				for	{set bit_input $MIN_BIT_INPUT} {$bit_input <= $MAX_BIT_INPUT}	{incr bit_input}	{

					set index [list $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $bit_input]

					set		result_tmp [lindex $results($index) 0]
					lappend	result_tmp [lindex $results($index) 1]

					# Redo using the min_propagation_delay
					#lappend	result_tmp [lindex $results($index) 2]
					lappend	result_tmp [expr {int([expr {ceil([lindex $results($index) 3]/$min_propagation_delay)}])}]

					lappend	result_tmp [lindex $results($index) 3]
					lappend	result_tmp [lindex $results($index) 4]

					# Updatete Results with the new extimation
					set results($index) $result_tmp

				}


			}
		}

	}
}

#----- test ------
# parray results
#-----------------

#-------------------------------------------------------------------------------



#--------------- Transform array result in list results_list ------------------
set results_list [list]
unset results_list

for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for	{set number_of_input $MIN_NUMBER_OF_INPUT} {$number_of_input <= $MAX_NUMBER_OF_INPUT} {incr number_of_input}	{

		for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
			for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {


				for	{set bit_input $MIN_BIT_INPUT} {$bit_input <= $MAX_BIT_INPUT}	{incr bit_input}	{


					lappend results_list $results([list $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $bit_input])

				}


			}
		}

	}
}
#-------------------------------------------------------------------------------




#----------------------------- Generate Package --------------------------------

# Constant Definition Section
set	constants_def [generate_constant_def $MIN_NUMBER_OF_INPUT $MAX_NUMBER_OF_INPUT $MIN_INPUT_ENGINE $MAX_INPUT_ENGINE $MIN_BIT_INPUT $MAX_BIT_INPUT]

# Types (Record/Array) Definition Section
set record_def				[generate_record_def]

set	free_running_range		[list 0 1]
set	number_of_input_range	[list "MIN_NUMBER_OF_INPUT" "MAX_NUMBER_OF_INPUT"]
set	max_input_engine_range	[list "MIN_INPUT_ENGINE" "MAX_INPUT_ENGINE"]
set	bit_input_range			[list "MIN_BIT_INPUT" "MAX_BIT_INPUT"]
set array_record_def		[generate_array_record_def $free_running_range $number_of_input_range $max_input_engine_range $bit_input_range]

set		types_def	$record_def
append	types_def	"\n"
append	types_def	$array_record_def


# Autocomputed Constants Section, LUTs, FFs, DELAY of Synth in ARRAY_RECORD
set	free_running_range		[list 0 1]
set	number_of_input_range	[list $MIN_NUMBER_OF_INPUT $MAX_NUMBER_OF_INPUT]
set	max_input_engine_range	[list $MIN_INPUT_ENGINE $MAX_INPUT_ENGINE]
set	bit_input_range			[list $MIN_BIT_INPUT $MAX_BIT_INPUT]
set constants_init	[generate_constant_array_record $free_running_range $number_of_input_range $max_input_engine_range $bit_input_range $results_list]

# Write package and body
set package [generate_package $package_name $constants_def $types_def $constants_init]
set body [generate_body $package_name]

# Write file vhd
set 	file_vhd	$header_1
append	file_vhd	"\n"
append	file_vhd	$header_2
append	file_vhd	"\n"
append	file_vhd	$description
append	file_vhd	"\n"
append	file_vhd	$default_library
append	file_vhd	"\n"
append	file_vhd	$others_library
append	file_vhd	"\n"
append	file_vhd	$package
append	file_vhd	"\n"
append	file_vhd	$body
#-------------------------------------------------------------------------------

#---------------------------- Write File Package -------------------------------
# Set path
set		package_path	$package_location
append	package_path	"/"
append	package_path	$package_name
append	package_path	".vhd"

# Open file_vhd for writing
set package_outputFile [open $package_path w]

# Put some text in to the file
puts $package_outputFile $file_vhd

# Close the file
close $package_outputFile
#-------------------------------------------------------------------------------

#===============================================================================
