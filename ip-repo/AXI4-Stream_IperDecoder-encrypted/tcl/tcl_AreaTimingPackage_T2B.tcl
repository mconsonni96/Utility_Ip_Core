#============================= SYNTH ANALISYS DEEFINE ==========================
# Range of Generics
set	MIN_BIT_T2B	2
set	MAX_BIT_T2B	12

set	MIN_INPUT_ENGINE	2
set	MAX_INPUT_ENGINE	4


# Regenerate Run Option
set REGENERATE_RUN	0

#===============================================================================


#============================== THIS PACKAGE DEFINE ============================

#-------------------------------- Name/Location ---------------------------------

#-------------------------------- Name/Location ---------------------------------
set package_location	"/home/nicola/Documents/Vivado/Utility_Ip_Core/ip_repo/TDC_Basic_IPs/thermometric-to-binary-converter/hdl"
set package_name		"AreaTimingPackage_T2B"
#-------------------------------------------------------------------------------

#------------------------------- Status/Location -------------------------------
set status_location	"/home/nicola/Documents/Vivado/Utility_Ip_Core/ip_repo/TDC_Basic_IPs/thermometric-to-binary-converter/txt"
set status_name		"status_tcl_AreaTimingPackage_T2B"
#-------------------------------------------------------------------------------


#--------------------------------- Description ---------------------------------
set		description	"-------------------------------------DESCRIPTION----------------------------------------\n"
append	description	"----------------------------------------------------------------------------------------\n"
append	description	"--								  Autogenerated Package  							   --\n"
append	description	"--	                Area Occupacy and Post-Synth Timing Analisis From ThermoToBin      --\n"
append	description	"----------------------------------------------------------------------------------------\n"
append	description	"----------------------------------------------------------------------------------------\n"

#-------------------------------------------------------------------------------

#===============================================================================



#============================== ALL PACKAGEs DEFINE ============================

#----------------------------------- Header ------------------------------------
set		header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"----  *   )                                                                                  ----\n"
append	header_1	"----` )  /( (      )      (    (           (  (  (            (    (   (   (          (  (   ----\n"
append	header_1	"---- ( )(_)))\\    (      ))\\   )\\    (     )\\))( )\\   (      ))\\  ))\\  )(  )\\   (     )\\))(  ----\n"
append	header_1	"----(_(_())((_)   )\\  ' /((_) ((_)   )\\ ) ((_))\\((_)  )\\ )  /((_)/((_)(()\\((_)  )\\ ) ((_))\\  ----\n"
append	header_1	"----|_   _| (_) _((_)) (_))   | __| _(_/(  (()(_)(_) _(_/( (_)) (_))   ((_)(_) _(_/(  (()(_) ----\n"
append	header_1	"----  | |   | || '  \\()/ -_)  | _| | ' \\))/ _` | | || ' \\))/ -_)/ -_) | '_|| || ' \\))/ _` |  ----\n"
append	header_1	"----  |_|   |_||_|_|_| \\___|  |___||_||_| \\__, | |_||_||_| \\___|\\___| |_|  |_||_||_| \\__, |  ----\n"
append	header_1	"----                                      |___/                                      |___/   ----\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"


set		header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"----           _____     _                      ___             __ _     _                                       _              __ _  ----\n"
append	header_2	"----    o O O |_   _|   (_)    _ __     ___    | __|   _ _     / _` |   (_)    _ _      ___     ___      _ _    (_)    _ _     / _` | ----\n"
append	header_2	"----   o        | |     | |   | '  \\   / -_)   | _|   | ' \\    \\__, |   | |   | ' \\    / -_)   / -_)    | '_|   | |   | ' \\    \\__, | ----\n"
append	header_2	"----  TS__\[O\]  _|_|_   _|_|_  |_|_|_|  \\___|   |___|  |_||_|   |___/   _|_|_  |_||_|   \\___|   \\___|   _|_|_   _|_|_  |_||_|   |___/  ----\n"
append	header_2	"---- {======|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"| ----\n"
append	header_2	"----./o--000'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-' ----\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"

#-------------------------------------------------------------------------------


#------------------------------ Libraty ----------------------------------------
set		default_library	"---------- DEFAULT LIBRARY ---------\n"
append	default_library	"library IEEE;\n"
append	default_library	"\tuse IEEE.STD_LOGIC_1164.all;\n"
append	default_library	"\tuse IEEE.NUMERIC_STD.ALL;\n"
append	default_library	"\t--use IEEE.MATH_REAL.all;\n"
append	default_library	"------------------------------------\n"

set		others_library	"---------- OTHERS LIBRARY ----------\n"
append	others_library	"-- NONE\n"
append	others_library	"------------------------------------\n"
#-------------------------------------------------------------------------------

#===============================================================================





#============================== ALL PACKAGES PROC ==============================

#------------------------------- Generate Package ------------------------------

proc generate_package {package_name constants_def types_def constants_init}\
{
	set		package	"package "
	append	package	$package_name
	append	package	" is\n"

	append	package	"\n"
	append	package	"\t--------------------------- Constants ----------------------------\n"
	append	package	"\n"
	append	package	$constants_def
	append	package	"\n"
	append	package	"\t-----------------------------------------------------------------\n"
	append	package	"\n"

	append	package	"\n"
	append	package	"\t---------------------------- Types Def ----------------------------\n"
	append	package	"\n"
	append	package	$types_def
	append	package	"\n"
	append	package	"\t-----------------------------------------------------------------\n"
	append	package	"\n"

	append	package	"\n"
	append	package	"\t---------------------------- Function ---------------------------\n"
	append	package	"\n"
	append	package	"\t------ Function Definition ----\n"
	append	package	"\t-- NONE\n"
	append	package	"\t-------------------------------\n"
	append	package	"\n"
	append	package	"\t-----------------------------------------------------------------\n"
	append	package	"\n"

	append	package	"\n"
	append	package	"\t-------------------- Autocomputed Constants ---------------------\n"
	append	package	"\n"
	append	package	$constants_init
	append	package	"\n"
	append	package	"\t-----------------------------------------------------------------\n"

	append	package	"end\t"
	append	package	$package_name
	append	package	";\n\n"

	return $package
}
#-------------------------------------------------------------------------------

#-------------------------------- Generate Body --------------------------------
proc generate_body {package_name}\
{
	set		body	"package body "
	append	body	$package_name
	append	body	" is\n"
	append	body	"\n"
	append	body	"\t---------------------------- Function ---------------------------\n"
	append	body	"\n"
	append	body	"\t------ Function Definition ----\n"
	append	body	"\t-- NONE\n"
	append	body	"\t-------------------------------\n"
	append	body	"\n"
	append	body	"\t-----------------------------------------------------------------\n"
	append	package	"\n"
	append	body	"end\t"
	append	body	$package_name
	append	body	";\n\n"

	return $body
}
#-------------------------------------------------------------------------------



#===============================================================================


#============================== THIS PACKAGE PROC ==============================

#------------------------- Generate AREA_TIMING_RECORD_TYPE -------------------
proc generate_constant_def {MIN_BIT_T2B MAX_BIT_T2B MIN_INPUT_ENGINE MAX_INPUT_ENGINE} \
{

	set		constant_def "\t--- Range of Number of Input ---\n"
	set		constant_def "\tconstant\tMIN_BIT_T2B\t:\tPOSITIVE\t:=\t$MIN_BIT_T2B;\n"
	append	constant_def "\tconstant\tMAX_BIT_T2B\t:\tPOSITIVE\t:=\t$MAX_BIT_T2B;\n"
	append	constant_def "\t-------------------------------\n"
	append	constant_def "\n"

	append	constant_def "\t---- Range of Max In Engine ---\n"
	append	constant_def "\tconstant\tMIN_INPUT_ENGINE\t:\tPOSITIVE\t:=\t$MIN_INPUT_ENGINE;\n"
	append	constant_def "\tconstant\tMAX_INPUT_ENGINE\t:\tPOSITIVE\t:=\t$MAX_INPUT_ENGINE;\n"
	append	constant_def "\t-------------------------------\n"
	append	constant_def "\n"

	return $constant_def
}
#-------------------------------------------------------------------------------

#------------------------- Generate AREA_TIMING_RECORD_TYPE -------------------
proc generate_record_def {} \
{

	set		record_def "\t-- Area and Timing Report --\n"
	append	record_def "\ttype\tAREA_TIMING_RECORD_TYPE\tis\trecord\n"
	append	record_def "\t\t--- Occuped Area ---\n"
	append	record_def "\t\tLUTs\t:\tNATURAL;\t-- Numbers of Total LUTs required\n"
	append	record_def "\t\tFFs\t\t:\tNATURAL;\t-- Numbers of Total FFs required\n"
	append	record_def "\t\t--------------------\n"
	append	record_def "\n"
	append	record_def "\t\t------- Timing ------\n"
	append	record_def "\t\tDELAY\t:\tNATURAL;\t-- Maximum Async Propagation Logic Delay espressed as min Async Propagation Logic Delay avaiable\n"
	append	record_def "\t\t--------------------\n"
	append	record_def "\tend\trecord\tAREA_TIMING_RECORD_TYPE;\n"
	append	record_def "\t----------------------------\n"

	return $record_def
}
#-------------------------------------------------------------------------------

#---------------------- Generate AREA_TIMING_ARRAY_RECORD_TYPE -----------------
proc generate_array_record_def {free_running_range edge_check_range bit_t2b_range max_input_engine_range invert_thermo_range} \
{
	set		array_record_def	"\t-- Area and Timing Array --\n"
	append	array_record_def	"\ttype\tAREA_TIMING_ARRAY_RECORD_TYPE\tis\tarray\t"
	append	array_record_def 	"([lindex $free_running_range 0] to [lindex $free_running_range 1],\t"
	append	array_record_def 	"[lindex $edge_check_range 0] to [lindex $edge_check_range 1],\t"

	append	array_record_def 	"[lindex $bit_t2b_range 0] to [lindex $bit_t2b_range 1],\t"
	append	array_record_def 	"[lindex $max_input_engine_range 0] to [lindex $max_input_engine_range 1],\t"
	append	array_record_def 	"[lindex $max_input_engine_range 0] to [lindex $max_input_engine_range 1],\t"
	append	array_record_def 	"[lindex $max_input_engine_range 0] to [lindex $max_input_engine_range 1],\t"
	append	array_record_def 	"[lindex $max_input_engine_range 0] to [lindex $max_input_engine_range 1],\t"

	append	array_record_def 	"[lindex $invert_thermo_range 0] to [lindex $invert_thermo_range 1])\t"
	append	array_record_def	"of AREA_TIMING_RECORD_TYPE;\n"
	append	array_record_def 	"\t--------------------\n"

	return $array_record_def
}
#-------------------------------------------------------------------------------


#---------------------- Generate constant AREA_TIMIMNG_USAGE -------------------
proc generate_constant_array_record {free_running_range edge_check_range invert_thermo_range max_input_engine_range bit_t2b_range results_list} \
{
	# Transform list results_list in array result
	array set results {}
	unset results

	set i 0


	for {set free_running [lindex $free_running_range 0]} {$free_running <= [lindex $free_running_range 1]} {incr free_running} {
		for {set edge_check [lindex $edge_check_range 0]} {$edge_check <= [lindex $edge_check_range 1]} {incr edge_check} {

			for	{set invert_thermo [lindex $invert_thermo_range 0]} {$invert_thermo <= [lindex $invert_thermo_range 1]} {incr invert_thermo}	{

				for	{set bit_t2b [lindex $bit_t2b_range 0]} {$bit_t2b <= [lindex $bit_t2b_range 1]} {incr bit_t2b}	{

					for {set max_input_engine_0 [lindex $max_input_engine_range 0]} {$max_input_engine_0 <= [lindex $max_input_engine_range 1]} {incr max_input_engine_0} {
						for {set max_input_engine_1 [lindex $max_input_engine_range 0]} {$max_input_engine_1 <= [lindex $max_input_engine_range 1]} {incr max_input_engine_1} {
							for {set max_input_engine_2 [lindex $max_input_engine_range 0]} {$max_input_engine_2 <= [lindex $max_input_engine_range 1]} {incr max_input_engine_2} {
								for {set max_input_engine_3 [lindex $max_input_engine_range 0]} {$max_input_engine_3 <= [lindex $max_input_engine_range 1]} {incr max_input_engine_3} {

									set results([list $free_running $edge_check $invert_thermo $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3  $bit_t2b]) [lindex $results_list $i]
									incr i

								}
							}
						}
					}

				}
			}

		}
	}




	set constant_array_record "\tconstant\tAREA_TIMING_USAGE\t:\tAREA_TIMING_ARRAY_RECORD_TYPE\t:=\n"

	append constant_array_record "\t(\n"

	for {set free_running [lindex $free_running_range 0] } {$free_running <= [lindex $free_running_range 1] } {incr free_running} {

		set free_running_boole	"FALSE"
		if {$free_running == [lindex $free_running_range 1]} { set free_running_boole	"TRUE" }

		append constant_array_record "\t\t(\n"

		for {set edge_check [lindex $edge_check_range 0]} {$edge_check <= [lindex $edge_check_range 1]} {incr edge_check} {

			set edge_check_boole	"FALSE"
			if {$edge_check == [lindex $edge_check_range 1]} { set edge_check_boole	"TRUE" }

			append constant_array_record "\t\t\t(\n"


		for {set invert_thermo [lindex $invert_thermo_range 0]} {$invert_thermo <= [lindex $invert_thermo_range 1]} {incr invert_thermo} {

			set invert_thermo_boole	"FALSE"
			if {$invert_thermo == [lindex $invert_thermo_range 1]} { set invert_thermo_boole	"TRUE" }

			append constant_array_record "\t\t\t\t(\n"




				for {set max_input_engine_0 [lindex $max_input_engine_range 0]} {$max_input_engine_0 <= [lindex $max_input_engine_range 1]} {incr max_input_engine_0} {

					append constant_array_record "\t\t\t\t\t(\n"

					for {set max_input_engine_1 [lindex $max_input_engine_range 0]} {$max_input_engine_1 <= [lindex $max_input_engine_range 1]} {incr max_input_engine_1} {

						append constant_array_record "\t\t\t\t\t\t(\n"

						for {set max_input_engine_2 [lindex $max_input_engine_range 0]} {$max_input_engine_2 <= [lindex $max_input_engine_range 1]} {incr max_input_engine_2} {

							append constant_array_record "\t\t\t\t\t\t\t(\n"

							for {set max_input_engine_3 [lindex $max_input_engine_range 0]} {$max_input_engine_3 <= [lindex $max_input_engine_range 1]} {incr max_input_engine_3} {

								append constant_array_record "\t\t\t\t\t\t\t\t(\n"

								for	{set bit_t2b [lindex $bit_t2b_range 0]} {$bit_t2b <= [lindex $bit_t2b_range 1]}	{incr bit_t2b}	{


									set tmp $results([list $free_running $edge_check $invert_thermo $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3  $bit_t2b])


									set luts	[lindex $tmp 0]
									set ffs		[lindex $tmp 1]
									set delay	[lindex $tmp 2]

									append constant_array_record "\t\t\t\t\t\t\t\t\t"
									append constant_array_record "("
									append constant_array_record $luts
									append constant_array_record ","
									append constant_array_record $ffs
									append constant_array_record ","
									append constant_array_record $delay
									append constant_array_record ")"

									if {$bit_t2b < [lindex $bit_t2b_range 1]} {
										append constant_array_record ","
									}

									append constant_array_record "\t--FREE_RUNNING = $free_running_boole,\tEDGE_CHECK = $edge_check_boole,\tINVERT_THERMO_IN = $invert_thermo,"
									append constant_array_record "\tMAX_INPUT_ENGINE_0 = $max_input_engine_0,\tMAX_INPUT_ENGINE_1 = $max_input_engine_1,"

									# IF bit_t2b MEANS BIt AT INPUT
									# append constant_array_record "\tMAX_INPUT_ENGINE_2 = $max_input_engine_2,\tMAX_INPUT_ENGINE_3 = $max_input_engine_3,\tBIT_THERMO = $bit_t2b\n"

									# IF bit_t2b MEANS BIt AT OUTPUT
									append constant_array_record "\tMAX_INPUT_ENGINE_2 = $max_input_engine_2,\tMAX_INPUT_ENGINE_3 = $max_input_engine_3,\tBIT_BIN = $bit_t2b\n"

								}

								append constant_array_record "\t\t\t\t\t\t\t\t)"
								if {$max_input_engine_3 < [lindex $max_input_engine_range 1]} {
									append constant_array_record ",\n"
								} else {
									append constant_array_record "\n"
								}
							}

							append constant_array_record "\t\t\t\t\t\t\t)"
							if {$max_input_engine_2 < [lindex $max_input_engine_range 1]} {
								append constant_array_record ",\n"
							} else {
								append constant_array_record "\n"
							}
						}

						append constant_array_record "\t\t\t\t\t\t)"
						if {$max_input_engine_1 < [lindex $max_input_engine_range 1]} {
							append constant_array_record ",\n"
						} else {
							append constant_array_record "\n"
						}
					}

					append constant_array_record "\t\t\t\t\t)"
					if {$max_input_engine_0 < [lindex $max_input_engine_range 1]} {
						append constant_array_record ",\n"
					} else {
						append constant_array_record "\n"
					}
				}


				append constant_array_record "\t\t\t\t)"
				if {$invert_thermo < [lindex $invert_thermo_range 1]} {
					append constant_array_record ",\n"
				} else {
					append constant_array_record "\n"
				}
			}


			append constant_array_record "\t\t\t)"
			if {$edge_check < [lindex $edge_check_range 1]} {
				append constant_array_record ",\n"
			} else {
				append constant_array_record "\n"
			}
		}

		append constant_array_record "\t\t)"
		if {$free_running < [lindex $free_running_range 1]} {
			append constant_array_record ",\n"
		} else {
			append constant_array_record "\n"
		}
	}

	append constant_array_record "\t);\n"

	return $constant_array_record
}
#-------------------------------------------------------------------------------
#===============================================================================




#======================== SYNTH ANALISYS PROCEDURE =============================
#-- Compute the LUTs FFs maxLogicCrossed max/min PathDelay with synth_design --
proc computeRecord_synth_design {free_running edge_check invert_thermo max_input_engine_0 max_input_engine_1 max_input_engine_2  max_input_engine_3 bit_t2b} \
{

	#-------------------------- Synthesis Project Mode -------------------------

	# IF bit_t2b MEANS BIt AT INPUT
	# set bit_in $bit_t2b
	# set bit_out [ expr int([expr [::tcl::mathfunc::ceil [expr [::tcl::mathfunc::log10 $bit_t2b]/[::tcl::mathfunc::log10 2]]]])]

	# IF bit_t2b MEANS BIt AT OUTPUT
	set bit_in [ expr 2**$bit_t2b]
	set bit_out $bit_t2b


	set 	generic_str "FREE_RUNNING=1'b[expr $free_running] "
	append 	generic_str "EDGE_CHECK=1'b[expr $edge_check] "

	append	generic_str	"MAX_INPUT_ENGINE_PIPELINE_STAGE0=[expr $max_input_engine_0] "
	append	generic_str	"MAX_INPUT_ENGINE_PIPELINE_STAGE1=[expr $max_input_engine_1] "
	append	generic_str	"MAX_INPUT_ENGINE_PIPELINE_STAGE2=[expr $max_input_engine_2] "
	append	generic_str	"MAX_INPUT_ENGINE_PIPELINE_STAGE3=[expr $max_input_engine_3] "

	append	generic_str	"INVERT_THERMO_IN=1'b[expr $invert_thermo] "

	append	generic_str	"BIT_THERMO=[expr $bit_in] "
	append	generic_str	"BIT_BIN=[expr $bit_out] "

	# Set the New Generic set (for safety)
	set_property GENERIC	$generic_str	[current_fileset]


	# Open the Syntehesis for the results computation in Out Of Context withou buffers
	synth_design -mode out_of_context

	#---------------------------------------------------------------------------


	#------------------------------ Results ------------------------------------


	# Compute the Number of FFs and LUTs
	set	LUTs	[llength [get_cells -hierarchical -filter { PRIMITIVE_TYPE =~ CLB.LUT.* } ]]
	set	FFs		[llength [get_cells -hierarchical -filter { PRIMITIVE_TYPE =~ REGISTER.SDR.* } ]]

	# Initializate the Post-Synthesis timing analisys
	create_clock -period 10.000 -name clk_test_timing -waveform {0.000 5.000} [get_nets Clk]

	# Identify the max and min propagation delay in nano seconds
	set	maxPathDelayNanoSec	[get_property DATAPATH_DELAY [get_timing_paths -setup ]]
	set	minPathDelayNanoSec	[get_property DATAPATH_DELAY [get_timing_paths -hold ]]

	# Set the number of logic crossed in from a FF to a FF
	if {$minPathDelayNanoSec == 0} {
		set maxLogicCrossed 1
	} else {
		set maxLogicCrossed [expr {int([expr {ceil($maxPathDelayNanoSec/$minPathDelayNanoSec)}])}]
	}



	# Save Results
	set results_synth [list $LUTs $FFs $maxLogicCrossed $maxPathDelayNanoSec $minPathDelayNanoSec]

	# Close the Post-Syntesis
	close_design
	#--------------------------------------------------------------------------

	return $results_synth

}
#-------------------------------------------------------------------------------


#-------- Compute the LUTs FFs maxLogicCrossed max/min PathDelay in run --------

proc computeRecord_launch_run {free_running edge_check invert_thermo max_input_engine_0 max_input_engine_1 max_input_engine_2  max_input_engine_3 bit_t2b regenerate_run} \
{


	#-------------------------- Synthesis Project Mode -------------------------
	# IF bit_t2b MEANS BIt AT INPUT
	# set bit_in $bit_t2b
	# set bit_out [ expr int([expr [::tcl::mathfunc::ceil [expr [::tcl::mathfunc::log10 $bit_t2b]/[::tcl::mathfunc::log10 2]]]])]

	# IF bit_t2b MEANS BIt AT OUTPUT
	set bit_in [ expr 2**$bit_t2b]
	set bit_out $bit_t2b


	set 	generic_str "FREE_RUNNING=1'b[expr $free_running] "
	append 	generic_str "FREE_RUNNING=1'b[expr $edge_check] "

	append	generic_str	"MAX_INPUT_ENGINE_PIPELINE_STAGE0=[expr $max_input_engine_0] "
	append	generic_str	"MAX_INPUT_ENGINE_PIPELINE_STAGE1=[expr $max_input_engine_1] "
	append	generic_str	"MAX_INPUT_ENGINE_PIPELINE_STAGE2=[expr $max_input_engine_2] "
	append	generic_str	"MAX_INPUT_ENGINE_PIPELINE_STAGE3=[expr $max_input_engine_3] "

	append	generic_str	"INVERT_THERMO_IN=1'b[expr $invert_thermo] "

	append	generic_str	"BIT_THERMO=[expr $bit_t2b] "
	append	generic_str	"BIT_BIN=[expr $bit_out] "




	set		synth_id	"synth_FR[expr $free_running]"
	append	synth_id	"_EC[expr $edge_check]"

	append	synth_id	"_INV[expr $invert_thermo]"

	append	synth_id	"_STAGE[expr $max_input_engine_0]"
	append	synth_id	"_STAGE[expr $max_input_engine_1]"
	append	synth_id	"_STAGE[expr $max_input_engine_2]"
	append	synth_id	"_STAGE[expr $max_input_engine_3]"

	append	synth_id	"_BT[expr $bit_t2b]"
	append	synth_id	"_BB[expr $bit_bin]"

	#-------------------------- Synthesis Project Mode -------------------------

	# Set the New Generic set (for safety)
	set_property GENERIC	$generic_str	[current_fileset]


	# Create and Run Specific Syntesis
	if {[get_runs $synth_id] != $synth_id} {

		# Create Synth Run
		create_run $synth_id -flow {Vivado Synthesis 2017}

		# Set the New Generic set
		set_property GENERIC	$generic_str	[current_fileset]

		# Launch the New Synthesis
		launch_runs	$synth_id	-jobs 6

		# Wait untill the Syntehesis is finished
		wait_on_run	$synth_id

	 # Open/Reset and ReRun an esisten Syntesis Rus
	} else {

		# Re Run only if request
		if { $regenerate_run == 1 } {

			# Reset Synth Run
			reset_run $synth_id

			# Set the New Generic set (for safety)
			set_property GENERIC	$generic_str	[current_fileset]

			# Launch the New Synthesis
			launch_runs	$synth_id	-jobs 6

			# Wait untill the Syntehesis is finished
			wait_on_run	$synth_id

		} else {

			open_run $synth_id -name $synth_id

		}
	}
	#---------------------------------------------------------------------------


	#------------------------------ Results ------------------------------------
	# Open the Syntehesis for the results computation in Out Of Context withou buffers
	synth_design -mode out_of_context

	# Compute the Number of FFs and LUTs
	set	LUTs	[llength [get_cells -hierarchical -filter { PRIMITIVE_TYPE =~ CLB.LUT.* } ]]
	set	FFs		[llength [get_cells -hierarchical -filter { PRIMITIVE_TYPE =~ REGISTER.SDR.* } ]]

	# Initializate the Post-Synthesis timing analisys
	create_clock -period 10.000 -name clk_test_timing -waveform {0.000 5.000} [get_nets clk]

	# Identify the max and min propagation delay in nano seconds
	set	maxPathDelayNanoSec	[get_property DATAPATH_DELAY [get_timing_paths -setup ]]
	set	minPathDelayNanoSec	[get_property DATAPATH_DELAY [get_timing_paths -hold ]]

	# Set the number of logic crossed in from a FF to a FF
	if {$minPathDelayNanoSec == 0} {
		set maxLogicCrossed 1
	} else {
		set maxLogicCrossed [expr {int([expr {ceil($maxPathDelayNanoSec/$minPathDelayNanoSec)}])}]
	}

	# Save Results
	set results_synth [list $LUTs $FFs $maxLogicCrossed $maxPathDelayNanoSec $minPathDelayNanoSec]

	# Close the Post-Syntesis
	close_design
	#--------------------------------------------------------------------------

	return $results_synth

}
#-------------------------------------------------------------------------------

#===============================================================================




#============================== USER DEFINED PROC ==============================

#------------------------------ int(ceil(a/b)) ----------------------------------

proc div_exc {a b} \
{

	set q [expr $a/$b]

	set r [expr $a%$b]

	if {$r != 0} {
		set q [expr $q+1]
	}

	return $q

}
#-------------------------------------------------------------------------------


#===============================================================================





#=============================== FULL SCRIPT INIT ==============================

#-------------------- Filter all possible Generics beetwen ---------------------
#              NUMBER_OF_INPUT and MAX_INPUT_ENGINE_PIPELINE_STAGEs

# Array LUT that filters the set of generics in that one usefull for the hdl
array set generic_array_flt {}
array set generic_array_flt_dbg {}

unset generic_array_flt
unset generic_array_flt_dbg



# IF bit_t2b < MAX_INPUT_ENGINE_PIPELINE_STAGE0
# Only one stage of pipeline set by MAX_INPUT_ENGINE_PIPELINE_STAGE0
for	{set bit_t2b $MIN_BIT_T2B} {$bit_t2b <= $MAX_BIT_T2B} {incr bit_t2b}	{

	for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
		for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {
			for {set max_input_engine_2 $MIN_INPUT_ENGINE} {$max_input_engine_2 <= $MAX_INPUT_ENGINE} {incr max_input_engine_2} {
				for {set max_input_engine_3 $MIN_INPUT_ENGINE} {$max_input_engine_3 <= $MAX_INPUT_ENGINE} {incr max_input_engine_3} {

					# Thresfolds
					set min_number_of_input_stage_0	$max_input_engine_0
					set min_number_of_input_stage_1	[expr $max_input_engine_1*$min_number_of_input_stage_0]
					set min_number_of_input_stage_2	[expr $max_input_engine_2*$min_number_of_input_stage_1]
					set min_number_of_input_stage_3	[expr $max_input_engine_3*$min_number_of_input_stage_2]

					if { $bit_t2b < $min_number_of_input_stage_0 & $bit_t2b < $min_number_of_input_stage_1 & $bit_t2b < $min_number_of_input_stage_2  & $bit_t2b < $min_number_of_input_stage_3} {

						set max_input_engine_0_res $bit_t2b

						if { $max_input_engine_0_res == 1} {
							set max_input_engine_0_res $MIN_INPUT_ENGINE
						}

						set generic_array_flt([list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ]) [list $max_input_engine_0_res $MIN_INPUT_ENGINE $MIN_INPUT_ENGINE $MIN_INPUT_ENGINE $bit_t2b]
						# Debug value with 0 index
						# set generic_array_flt([list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ]) [list $max_input_engine_0_res $MIN_INPUT_ENGINE $MIN_INPUT_ENGINE $MIN_INPUT_ENGINE $bit_t2b "0"]					}
				}
			}
		}
	}

}



# IF bit_t2b >= MAX_INPUT_ENGINE_PIPELINE_STAGE0*MAX_INPUT_ENGINE_PIPELINE_STAGE1
# Only two stages of pipeline, fist full, set by MAX_INPUT_ENGINE_PIPELINE_STAGE0 and MAX_INPUT_ENGINE_PIPELINE_STAGE1
for	{set bit_t2b $MIN_BIT_T2B} {$bit_t2b <= $MAX_BIT_T2B} {incr bit_t2b}	{

	for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
		for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {
			for {set max_input_engine_2 $MIN_INPUT_ENGINE} {$max_input_engine_2 <= $MAX_INPUT_ENGINE} {incr max_input_engine_2} {
				for {set max_input_engine_3 $MIN_INPUT_ENGINE} {$max_input_engine_3 <= $MAX_INPUT_ENGINE} {incr max_input_engine_3} {

					# Thresfolds
					set min_number_of_input_stage_0	$max_input_engine_0
					set min_number_of_input_stage_1	[expr $max_input_engine_1*$min_number_of_input_stage_0]
					set min_number_of_input_stage_2	[expr $max_input_engine_2*$min_number_of_input_stage_1]
					set min_number_of_input_stage_3	[expr $max_input_engine_3*$min_number_of_input_stage_2]

					if { $bit_t2b >= $min_number_of_input_stage_0 & $bit_t2b < $min_number_of_input_stage_1 & $bit_t2b < $min_number_of_input_stage_2  & $bit_t2b < $min_number_of_input_stage_3} {

						set max_input_engine_1_res [div_exc $bit_t2b $max_input_engine_0]

						if { $max_input_engine_1_res == 1} {
							set max_input_engine_1_res $MIN_INPUT_ENGINE
						}

						set generic_array_flt([list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ]) [list $max_input_engine_0 $max_input_engine_1_res $MIN_INPUT_ENGINE $MIN_INPUT_ENGINE $bit_t2b ]
						# Debug value with 1 index
						# set generic_array_flt([list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ]) [list $max_input_engine_0 $max_input_engine_1_res $MIN_INPUT_ENGINE $MIN_INPUT_ENGINE $bit_t2b "1"]
					}
				}
			}

		}
	}

}



# IF bit_t2b >= MAX_INPUT_ENGINE_PIPELINE_STAGE0*MAX_INPUT_ENGINE_PIPELINE_STAGE1*MAX_INPUT_ENGINE_PIPELINE_STAGE2
# Only three stages of pipeline, fist and second full, set by MAX_INPUT_ENGINE_PIPELINE_STAGE0, MAX_INPUT_ENGINE_PIPELINE_STAGE2 and MAX_INPUT_ENGINE_PIPELINE_STAGE1
for	{set bit_t2b $MIN_BIT_T2B} {$bit_t2b <= $MAX_BIT_T2B} {incr bit_t2b}	{

	for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
		for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {
			for {set max_input_engine_2 $MIN_INPUT_ENGINE} {$max_input_engine_2 <= $MAX_INPUT_ENGINE} {incr max_input_engine_2} {
				for {set max_input_engine_3 $MIN_INPUT_ENGINE} {$max_input_engine_3 <= $MAX_INPUT_ENGINE} {incr max_input_engine_3} {

					# Thresfolds
					set min_number_of_input_stage_0	$max_input_engine_0
					set min_number_of_input_stage_1	[expr $max_input_engine_1*$min_number_of_input_stage_0]
					set min_number_of_input_stage_2	[expr $max_input_engine_2*$min_number_of_input_stage_1]
					set min_number_of_input_stage_3	[expr $max_input_engine_3*$min_number_of_input_stage_2]

					if { $bit_t2b >= $min_number_of_input_stage_0 & $bit_t2b >= $min_number_of_input_stage_1 & $bit_t2b < $min_number_of_input_stage_2  & $bit_t2b < $min_number_of_input_stage_3} {

						set max_input_engine_2_res [div_exc [div_exc $bit_t2b $max_input_engine_0] $max_input_engine_1]

						if { $max_input_engine_2_res == 1} {
							set max_input_engine_2_res $MIN_INPUT_ENGINE
						}

						set generic_array_flt([list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ]) [list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2_res $MIN_INPUT_ENGINE ]
						# Debug value with 2 index
						# set generic_array_flt([list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ]) [list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2_res $MIN_INPUT_ENGINE "2"]

					}
				}
			}
		}
	}

}



# IF bit_t2b >= MAX_INPUT_ENGINE_PIPELINE_STAGE0*MAX_INPUT_ENGINE_PIPELINE_STAGE1*MAX_INPUT_ENGINE_PIPELINE_STAGE2
# Only three stages of pipeline, fist, second and third full, set by MAX_INPUT_ENGINE_PIPELINE_STAGE0, MAX_INPUT_ENGINE_PIPELINE_STAGE1 and MAX_INPUT_ENGINE_PIPELINE_STAGE2
for	{set bit_t2b $MIN_BIT_T2B} {$bit_t2b <= $MAX_BIT_T2B} {incr bit_t2b}	{

	for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
		for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {
			for {set max_input_engine_2 $MIN_INPUT_ENGINE} {$max_input_engine_2 <= $MAX_INPUT_ENGINE} {incr max_input_engine_2} {
				for {set max_input_engine_3 $MIN_INPUT_ENGINE} {$max_input_engine_3 <= $MAX_INPUT_ENGINE} {incr max_input_engine_3} {

					# Thresfolds
					set min_number_of_input_stage_0	$max_input_engine_0
					set min_number_of_input_stage_1	[expr $max_input_engine_1*$min_number_of_input_stage_0]
					set min_number_of_input_stage_2	[expr $max_input_engine_2*$min_number_of_input_stage_1]
					set min_number_of_input_stage_3	[expr $max_input_engine_3*$min_number_of_input_stage_2]

					if { $bit_t2b >= $min_number_of_input_stage_0 & $bit_t2b >= $min_number_of_input_stage_1 & $bit_t2b >= $min_number_of_input_stage_2  & $bit_t2b < $min_number_of_input_stage_3} {

						set max_input_engine_3_res  [div_exc [div_exc [div_exc [div_exc $bit_t2b $max_input_engine_0] $max_input_engine_1] $max_input_engine_2] $max_input_engine_3]

						if { $max_input_engine_3_res == 1} {
							set max_input_engine_3_res $MIN_INPUT_ENGINE
						}

						set generic_array_flt([list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ]) [list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3_res $bit_t2b ]
						# Debug value with 3 index
						# set generic_array_flt([list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ]) [list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3_res $bit_t2b "3"]
					}
				}
			}
		}
	}

}



# IF bit_t2b >= MAX_INPUT_ENGINE_PIPELINE_STAGE0*MAX_INPUT_ENGINE_PIPELINE_STAGE1*MAX_INPUT_ENGINE_PIPELINE_STAGE2*MAX_INPUT_ENGINE_PIPELINE_STAGE3
# Four or More stages of pipeline, all full, set by MAX_INPUT_ENGINE_PIPELINE_STAGE0, MAX_INPUT_ENGINE_PIPELINE_STAGE1, MAX_INPUT_ENGINE_PIPELINE_STAGE2 and MAX_INPUT_ENGINE_PIPELINE_STAGE3
for	{set bit_t2b $MIN_BIT_T2B} {$bit_t2b <= $MAX_BIT_T2B} {incr bit_t2b}	{

	for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
		for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {
			for {set max_input_engine_2 $MIN_INPUT_ENGINE} {$max_input_engine_2 <= $MAX_INPUT_ENGINE} {incr max_input_engine_2} {
				for {set max_input_engine_3 $MIN_INPUT_ENGINE} {$max_input_engine_3 <= $MAX_INPUT_ENGINE} {incr max_input_engine_3} {

					# Thresfolds
					set min_number_of_input_stage_0	$max_input_engine_0
					set min_number_of_input_stage_1	[expr $max_input_engine_1*$min_number_of_input_stage_0]
					set min_number_of_input_stage_2	[expr $max_input_engine_2*$min_number_of_input_stage_1]
					set min_number_of_input_stage_3	[expr $max_input_engine_3*$min_number_of_input_stage_2]

					if { $bit_t2b >= $min_number_of_input_stage_0 & $bit_t2b >= $min_number_of_input_stage_1 & $bit_t2b >= $min_number_of_input_stage_2  & $bit_t2b >= $min_number_of_input_stage_3} {
						set generic_array_flt([list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ]) [list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ]

						# Debug value with 4 index
						# set generic_array_flt([list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ]) [list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b "4"]
					}

				}
			}
		}
	}

}


#----- test ------
# parray generic_array_flt
# parray generic_array_flt_dbg
#-----------------

#-------------------------------------------------------------------------------



#---------------- Full Generics Set is TO_SYNTh or to_copy ---------------------
#								FOR DEBUGGING

# Find the results and puts in array
array set full_generic_array_flt {}
unset full_generic_array_flt


# Minimum Value
set ref [list 1 1 1 1 1]

set total_cores 0
set cores_to_synth 0
set cores_to_copy 0

for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for {set edge_check 0} {$edge_check <= 1} {incr edge_check} {
		for {set invert_thermo 0} {$invert_thermo <= 1} {incr invert_thermo} {

			# Use the generics_array_flt as LUT
			for	{set bit_t2b $MIN_BIT_T2B} {$bit_t2b <= $MAX_BIT_T2B} {incr bit_t2b}	{

				for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
					for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {
						for {set max_input_engine_2 $MIN_INPUT_ENGINE} {$max_input_engine_2 <= $MAX_INPUT_ENGINE} {incr max_input_engine_2} {
							for {set max_input_engine_3 $MIN_INPUT_ENGINE} {$max_input_engine_3 <= $MAX_INPUT_ENGINE} {incr max_input_engine_3} {

								incr total_cores
								set generics_array_flt_set	$generic_array_flt([list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ])

								# If the generics set is new
								if { $generics_array_flt_set != $ref } {
									# Target as To Synth
									set full_generic_array_flt([list $free_running $edge_check $invert_thermo $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ])  [concat [list $free_running $edge_check $invert_thermo] $generics_array_flt_set [list "TO_SYNTH"]]
									set ref $generics_array_flt_set
									incr cores_to_synth
								} else {
									# Target as To Copy
									set full_generic_array_flt([list $free_running $edge_check $invert_thermo $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b ]) [concat [list $free_running $edge_check $invert_thermo] $generics_array_flt_set [list "to_copy"]]
									incr cores_to_copy
								}



							}
						}
					}
				}

			}

		}
	}
}

#----- test ------
# parray full_generic_array_flt
# puts $total_cores
# puts $cores_to_synth
# puts $cores_to_copy
#-----------------


#-- Write Status --

# Set status
set 	file_txt "========== PRE-ANALISYS ==========\n"
append	file_txt "Cores To Synth\t$cores_to_synth\n"
append	file_txt "Cores To Copy\t$cores_to_copy\n"
append	file_txt "Total Cores \t$total_cores\n"
append 	file_txt "==================================\n\n"

# Set path
set		status_path	$status_location
append	status_path	"/"
append	status_path	$status_name
append	status_path	".txt"

# Open file_vhd for writing
set status_outputFile [open $status_path w]

# Put some text in to the file
puts $status_outputFile $file_txt

# Close the file
close $status_outputFile
#-----------------


#-------------------------------------------------------------------------------

#===============================================================================




#================================ FULL SCRIPT ==================================


#------------------ Full Generics Set  TO_SYNTh or to_copy ---------------------
#						FOR SYNTH AND ANALISYS


# Find the results and puts in array
array set results {}
unset results

set total_cores 0
set cores_to_synth 0
set cores_to_copy 0

set ref [list 1 1 1 1 1]

for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for {set edge_check 0} {$edge_check <= 1} {incr edge_check} {
		for {set invert_thermo 0} {$invert_thermo <= 1} {incr invert_thermo} {

			# Use the generics_array_flt as LUT
			for	{set bit_t2b $MIN_BIT_T2B} {$bit_t2b <= $MAX_BIT_T2B} {incr bit_t2b}	{

				for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
					for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {
						for {set max_input_engine_2 $MIN_INPUT_ENGINE} {$max_input_engine_2 <= $MAX_INPUT_ENGINE} {incr max_input_engine_2} {
							for {set max_input_engine_3 $MIN_INPUT_ENGINE} {$max_input_engine_3 <= $MAX_INPUT_ENGINE} {incr max_input_engine_3} {


								incr total_cores

								set generics_array_flt_set	$generic_array_flt([list $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b])

								# If the generics set is new
								if { $generics_array_flt_set != $ref } {

									# To Synth
									# set results([list $free_running $number_of_input $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_input]) [computeRecord_launch_run $free_running $edge_check $invert_thermo $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b $REGENERATE_RUN]
									set results([list $free_running $edge_check $invert_thermo $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b]) [computeRecord_synth_design $free_running $edge_check $invert_thermo $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b]

									set ref $generics_array_flt_set
									set index [list $free_running $edge_check $invert_thermo $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b]

									incr cores_to_synth

								} else {
									# Target as To Copy
									set results([list $free_running $edge_check $invert_thermo $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b]) $results($index)

									incr cores_to_copy

								}


								#-- Write Status --
								# Open file_vhd for writing
								set status_outputFile [open $status_path w]

								# Set status
								set		file_txt_tmp $file_txt
								append 	file_txt_tmp "========== EXE-ANALISYS ==========\n"
								append 	file_txt_tmp "Synth\t$cores_to_synth\n"
								append 	file_txt_tmp "Copy\t$cores_to_copy\n"
								append 	file_txt_tmp "Total\t$total_cores\n"
								append 	file_txt_tmp "==================================\n"


								# Put some text in to the file
								puts $status_outputFile $file_txt_tmp

								# Close the file
								close $status_outputFile
								#-----------------

							}
						}
					}
				}

			}

		}
	}
}


#----- test ------
# parray results
#-----------------

#-------------------------------------------------------------------------------



#--- Find the min Propagation Delay For Better Extimation of maxLogicCrossed ---

# Find the min_propagation_delay in all the synth avaiable
set min_propagation_delay_list [list]
unset min_propagation_delay_list

for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for {set edge_check 0} {$edge_check <= 1} {incr edge_check} {
		for {set invert_thermo 0} {$invert_thermo <= 1} {incr invert_thermo} {

			# Use the generics_array_flt as LUT
			for	{set bit_t2b $MIN_BIT_T2B} {$bit_t2b <= $MAX_BIT_T2B} {incr bit_t2b}	{

				for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
					for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {
						for {set max_input_engine_2 $MIN_INPUT_ENGINE} {$max_input_engine_2 <= $MAX_INPUT_ENGINE} {incr max_input_engine_2} {
							for {set max_input_engine_3 $MIN_INPUT_ENGINE} {$max_input_engine_3 <= $MAX_INPUT_ENGINE} {incr max_input_engine_3} {



								set min_propagation_delay_tmp	[ lindex $results([list  $free_running $edge_check $invert_thermo $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b]) 4]
								if {$min_propagation_delay_tmp > 0 } {

									lappend min_propagation_delay_list $min_propagation_delay_tmp

								}
							}
						}
					}

				}

			}
		}
	}
}

# The min is the first not zero
set min_propagation_delay [lindex [ lsort $min_propagation_delay_list] 0]

# Redo the computation of the MaxLogicCrossed
for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for {set edge_check 0} {$edge_check <= 1} {incr edge_check} {
		for {set invert_thermo 0} {$invert_thermo <= 1} {incr invert_thermo} {

			# Use the generics_array_flt as LUT
			for	{set bit_t2b $MIN_BIT_T2B} {$bit_t2b <= $MAX_BIT_T2B} {incr bit_t2b}	{

				for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
					for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {
						for {set max_input_engine_2 $MIN_INPUT_ENGINE} {$max_input_engine_2 <= $MAX_INPUT_ENGINE} {incr max_input_engine_2} {
							for {set max_input_engine_3 $MIN_INPUT_ENGINE} {$max_input_engine_3 <= $MAX_INPUT_ENGINE} {incr max_input_engine_3} {

								set index [list $free_running $edge_check $invert_thermo $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b]

								set		result_tmp [lindex $results($index) 0]
								lappend	result_tmp [lindex $results($index) 1]

								# Redo using the min_propagation_delay
								#lappend	result_tmp [lindex $results($index) 2]
								lappend	result_tmp [expr {int([expr {ceil([lindex $results($index) 3]/$min_propagation_delay)}])}]

								lappend	result_tmp [lindex $results($index) 3]
								lappend	result_tmp [lindex $results($index) 4]

								# Updatete Results with the new extimation
								set results($index) $result_tmp

							}
						}
					}
				}

			}

		}
	}
}

#----- test ------
# parray results
#-----------------

#-------------------------------------------------------------------------------



#--------------- Transform array result in list results_list ------------------
set results_list [list]
unset results_list

for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for {set edge_check 0} {$edge_check <= 1} {incr edge_check} {
		for {set invert_thermo 0} {$invert_thermo <= 1} {incr invert_thermo} {

			# Use the generics_array_flt as LUT
			for	{set bit_t2b $MIN_BIT_T2B} {$bit_t2b <= $MAX_BIT_T2B} {incr bit_t2b}	{

				for {set max_input_engine_0 $MIN_INPUT_ENGINE} {$max_input_engine_0 <= $MAX_INPUT_ENGINE} {incr max_input_engine_0} {
					for {set max_input_engine_1 $MIN_INPUT_ENGINE} {$max_input_engine_1 <= $MAX_INPUT_ENGINE} {incr max_input_engine_1} {
						for {set max_input_engine_2 $MIN_INPUT_ENGINE} {$max_input_engine_2 <= $MAX_INPUT_ENGINE} {incr max_input_engine_2} {
							for {set max_input_engine_3 $MIN_INPUT_ENGINE} {$max_input_engine_3 <= $MAX_INPUT_ENGINE} {incr max_input_engine_3} {


								lappend results_list $results([list $free_running $edge_check $invert_thermo $max_input_engine_0 $max_input_engine_1 $max_input_engine_2 $max_input_engine_3 $bit_t2b])

							}
						}
					}
				}

			}

		}
	}
}
#-------------------------------------------------------------------------------




#----------------------------- Generate Package --------------------------------

# Constant Definition Section
set	constants_def [generate_constant_def $MIN_BIT_T2B $MAX_BIT_T2B $MIN_INPUT_ENGINE $MAX_INPUT_ENGINE]

# Types (Record/Array) Definition Section
set record_def				[generate_record_def]

set	free_running_range		[list 0 1]
set	edge_check_range		[list 0 1]
set	invert_thermo_range		[list 0 1]
set	max_input_engine_range	[list "MIN_INPUT_ENGINE" "MAX_INPUT_ENGINE"]
set	bit_t2b_range			[list "MIN_BIT_T2B" "MAX_BIT_T2B"]
set array_record_def		[generate_array_record_def $free_running_range $edge_check_range $invert_thermo_range $max_input_engine_range $bit_t2b_range]

set		types_def	$record_def
append	types_def	"\n"
append	types_def	$array_record_def


# Autocomputed Constants Section, LUTs, FFs, DELAY of Synth in ARRAY_RECORD
set	free_running_range		[list 0 1]
set	edge_check_range		[list 0 1]
set	invert_thermo_range		[list 0 1]
set	max_input_engine_range	[list $MIN_INPUT_ENGINE $MAX_INPUT_ENGINE]
set	bit_t2b_range			[list $MIN_BIT_T2B $MAX_BIT_T2B]
set constants_init	[generate_constant_array_record $free_running_range $edge_check_range $invert_thermo_range $max_input_engine_range $bit_t2b_range $results_list]



# Write package and body
set package [generate_package $package_name $constants_def $types_def $constants_init]
set body [generate_body $package_name]

# Write file vhd
set 	file_vhd	$header_1
append	file_vhd	"\n"
append	file_vhd	$header_2
append	file_vhd	"\n"
append	file_vhd	$description
append	file_vhd	"\n"
append	file_vhd	$default_library
append	file_vhd	"\n"
append	file_vhd	$others_library
append	file_vhd	"\n"
append	file_vhd	$package
append	file_vhd	"\n"
append	file_vhd	$body
#-------------------------------------------------------------------------------

#---------------------------- Write File Package -------------------------------
# Set path
set		package_path	$package_location
append	package_path	"/"
append	package_path	$package_name
append	package_path	".vhd"

# Open file_vhd for writing
set package_outputFile [open $package_path w]

# Put some text in to the file
puts $package_outputFile $file_vhd

# Close the file
close $package_outputFile
#-------------------------------------------------------------------------------

#===============================================================================
