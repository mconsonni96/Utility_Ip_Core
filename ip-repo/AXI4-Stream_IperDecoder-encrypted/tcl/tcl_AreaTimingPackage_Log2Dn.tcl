#============================= SYNTH ANALISYS DEEFINE ==========================
# Range of Generics
set	MIN_BIT_LOG2	2
set	MAX_BIT_LOG2	12

# Regenerate Run Option
set REGENERATE_RUN	0

#===============================================================================


#============================== THIS PACKAGE DEFINE ============================


#-------------------------------- Name/Location ---------------------------------
set package_location	"/home/nicola/Documents/Vivado/Utility_Ip_Core/ip_repo/TDC_Basic_IPs/log2-down-edge/hdl"
set package_name		"AreaTimingPackage_Log2Dn"
#-------------------------------------------------------------------------------

#------------------------------- Status/Location -------------------------------
set status_location	"/home/nicola/Documents/Vivado/Utility_Ip_Core/ip_repo/TDC_Basic_IPs/log2-down-edge/txt"
set status_name		"status_tcl_AreaTimingPackage_Log2Dn"
#-------------------------------------------------------------------------------


#--------------------------------- Description ---------------------------------
set		description	"-------------------------------------DESCRIPTION----------------------------------------\n"
append	description	"----------------------------------------------------------------------------------------\n"
append	description	"--								  Autogenerated Package  							   --\n"
append	description	"--	                  Area Occupacy and Post-Synth Timing Analisis From Log2Dn         --\n"
append	description	"----------------------------------------------------------------------------------------\n"
append	description	"----------------------------------------------------------------------------------------\n"

#-------------------------------------------------------------------------------

#===============================================================================


#============================== ALL PACKAGEs DEFINE ============================

#----------------------------------- Header ------------------------------------
set		header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"----  *   )                                                                                  ----\n"
append	header_1	"----` )  /( (      )      (    (           (  (  (            (    (   (   (          (  (   ----\n"
append	header_1	"---- ( )(_)))\\    (      ))\\   )\\    (     )\\))( )\\   (      ))\\  ))\\  )(  )\\   (     )\\))(  ----\n"
append	header_1	"----(_(_())((_)   )\\  ' /((_) ((_)   )\\ ) ((_))\\((_)  )\\ )  /((_)/((_)(()\\((_)  )\\ ) ((_))\\  ----\n"
append	header_1	"----|_   _| (_) _((_)) (_))   | __| _(_/(  (()(_)(_) _(_/( (_)) (_))   ((_)(_) _(_/(  (()(_) ----\n"
append	header_1	"----  | |   | || '  \\()/ -_)  | _| | ' \\))/ _` | | || ' \\))/ -_)/ -_) | '_|| || ' \\))/ _` |  ----\n"
append	header_1	"----  |_|   |_||_|_|_| \\___|  |___||_||_| \\__, | |_||_||_| \\___|\\___| |_|  |_||_||_| \\__, |  ----\n"
append	header_1	"----                                      |___/                                      |___/   ----\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"
append	header_1	"-------------------------------------------------------------------------------------------------\n"


set		header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"----           _____     _                      ___             __ _     _                                       _              __ _  ----\n"
append	header_2	"----    o O O |_   _|   (_)    _ __     ___    | __|   _ _     / _` |   (_)    _ _      ___     ___      _ _    (_)    _ _     / _` | ----\n"
append	header_2	"----   o        | |     | |   | '  \\   / -_)   | _|   | ' \\    \\__, |   | |   | ' \\    / -_)   / -_)    | '_|   | |   | ' \\    \\__, | ----\n"
append	header_2	"----  TS__\[O\]  _|_|_   _|_|_  |_|_|_|  \\___|   |___|  |_||_|   |___/   _|_|_  |_||_|   \\___|   \\___|   _|_|_   _|_|_  |_||_|   |___/  ----\n"
append	header_2	"---- {======|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"| ----\n"
append	header_2	"----./o--000'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-'\"`-0-0-' ----\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"
append	header_2	"------------------------------------------------------------------------------------------------------------------------------------------\n"

#-------------------------------------------------------------------------------


#------------------------------ Libraty ----------------------------------------
set		default_library	"---------- DEFAULT LIBRARY ---------\n"
append	default_library	"library IEEE;\n"
append	default_library	"\tuse IEEE.STD_LOGIC_1164.all;\n"
append	default_library	"\tuse IEEE.NUMERIC_STD.ALL;\n"
append	default_library	"\t--use IEEE.MATH_REAL.all;\n"
append	default_library	"------------------------------------\n"

set		others_library	"---------- OTHERS LIBRARY ----------\n"
append	others_library	"-- NONE\n"
append	others_library	"------------------------------------\n"
#-------------------------------------------------------------------------------

#===============================================================================





#============================== ALL PACKAGES PROC ==============================

#------------------------------- Generate Package ------------------------------

proc generate_package {package_name constants_def types_def constants_init}\
{
	set		package	"package "
	append	package	$package_name
	append	package	" is\n"

	append	package	"\n"
	append	package	"\t--------------------------- Constants ----------------------------\n"
	append	package	"\n"
	append	package	$constants_def
	append	package	"\n"
	append	package	"\t-----------------------------------------------------------------\n"
	append	package	"\n"

	append	package	"\n"
	append	package	"\t---------------------------- Types Def ----------------------------\n"
	append	package	"\n"
	append	package	$types_def
	append	package	"\n"
	append	package	"\t-----------------------------------------------------------------\n"
	append	package	"\n"

	append	package	"\n"
	append	package	"\t---------------------------- Function ---------------------------\n"
	append	package	"\n"
	append	package	"\t------ Function Definition ----\n"
	append	package	"\t-- NONE\n"
	append	package	"\t-------------------------------\n"
	append	package	"\n"
	append	package	"\t-----------------------------------------------------------------\n"
	append	package	"\n"

	append	package	"\n"
	append	package	"\t-------------------- Autocomputed Constants ---------------------\n"
	append	package	"\n"
	append	package	$constants_init
	append	package	"\n"
	append	package	"\t-----------------------------------------------------------------\n"

	append	package	"end\t"
	append	package	$package_name
	append	package	";\n\n"

	return $package
}
#-------------------------------------------------------------------------------

#-------------------------------- Generate Body --------------------------------
proc generate_body {package_name}\
{
	set		body	"package body "
	append	body	$package_name
	append	body	" is\n"
	append	body	"\n"
	append	body	"\t---------------------------- Function ---------------------------\n"
	append	body	"\n"
	append	body	"\t------ Function Definition ----\n"
	append	body	"\t-- NONE\n"
	append	body	"\t-------------------------------\n"
	append	body	"\n"
	append	body	"\t-----------------------------------------------------------------\n"
	append	package	"\n"
	append	body	"end\t"
	append	body	$package_name
	append	body	";\n\n"

	return $body
}
#-------------------------------------------------------------------------------



#===============================================================================


#============================== THIS PACKAGE PROC ==============================

#------------------------- Generate AREA_TIMING_RECORD_TYPE -------------------
proc generate_constant_def {MIN_BIT_LOG2 MAX_BIT_LOG2} \
{

	set		constant_def "\tconstant\tMIN_BIT_LOG2\t:\tPOSITIVE\t:=\t$MIN_BIT_LOG2;\n"
	append	constant_def "\tconstant\tMAX_BIT_LOG2\t:\tPOSITIVE\t:=\t$MAX_BIT_LOG2;\n"

	return $constant_def
}
#-------------------------------------------------------------------------------

#------------------------- Generate AREA_TIMING_RECORD_TYPE -------------------
proc generate_record_def {} \
{

	set		record_def "\t-- Area and Timing Report --\n"
	append	record_def "\ttype\tAREA_TIMING_RECORD_TYPE\tis\trecord\n"
	append	record_def "\t\t--- Occuped Area ---\n"
	append	record_def "\t\tLUTs\t:\tNATURAL;\t-- Numbers of Total LUTs required\n"
	append	record_def "\t\tFFs\t\t:\tNATURAL;\t-- Numbers of Total FFs required\n"
	append	record_def "\t\t--------------------\n"
	append	record_def "\n"
	append	record_def "\t\t------- Timing ------\n"
	append	record_def "\t\tDELAY\t:\tNATURAL;\t-- Maximum Async Propagation Logic Delay espressed as min Async Propagation Logic Delay avaiable\n"
	append	record_def "\t\t--------------------\n"
	append	record_def "\tend\trecord\tAREA_TIMING_RECORD_TYPE;\n"
	append	record_def "\t----------------------------\n"

	return $record_def
}
#-------------------------------------------------------------------------------

#---------------------- Generate AREA_TIMING_ARRAY_RECORD_TYPE -----------------
proc generate_array_record_def {free_running_range edge_check_range bit_log2_range} \
{
	set		array_record_def	"\t-- Area and Timing Array --\n"
	append	array_record_def	"\ttype\tAREA_TIMING_ARRAY_RECORD_TYPE\tis\tarray\t"
	append	array_record_def 	"([lindex $free_running_range 0] to [lindex $free_running_range 1],\t"
	append	array_record_def 	"[lindex $edge_check_range 0] to [lindex $edge_check_range 1],\t"
	append	array_record_def 	"[lindex $bit_log2_range 0] to [lindex $bit_log2_range 1])\t"
	append	array_record_def	"of AREA_TIMING_RECORD_TYPE;\n"
	append	array_record_def 	"\t--------------------\n"

	return $array_record_def
}
#-------------------------------------------------------------------------------


#---------------------- Generate constant AREA_TIMIMNG_USAGE -------------------
proc generate_constant_array_record {free_running_range edge_check_range bit_log2_range results_list} \
{
	# Transform list results_list in array result
	array set results {}
	unset results

	set i 0
	for {set free_running [lindex $free_running_range 0]} {$free_running <= [lindex $free_running_range 1]} {incr free_running} {
		for {set edge_check [lindex $edge_check_range 0]} {$edge_check <= [lindex $edge_check_range 1]} {incr edge_check} {
			for	{set bit_log2 [lindex $bit_log2_range 0]} {$bit_log2 <= [lindex $bit_log2_range 1]} {incr bit_log2}	{

				set results([list $free_running $edge_check $bit_log2]) [lindex $results_list $i]
				incr i


			}
		}
	}


	set constant_array_record "\tconstant\tAREA_TIMING_USAGE\t:\tAREA_TIMING_ARRAY_RECORD_TYPE\t:=\n"

	append constant_array_record "\t(\n"

	for {set free_running [lindex $free_running_range 0] } {$free_running <= [lindex $free_running_range 1] } {incr free_running} {

		set free_running_boole	"FALSE"
		if {$free_running == [lindex $free_running_range 1]} { set free_running_boole	"TRUE" }

		append constant_array_record "\t\t(\n"

		for {set edge_check [lindex $edge_check_range 0]} {$edge_check <= [lindex $edge_check_range 1]} {incr edge_check} {

			set edge_check_boole	"FALSE"
			if {$edge_check == [lindex $edge_check_range 1]} { set edge_check_boole	"TRUE" }

			append constant_array_record "\t\t\t(\n"

			for	{set bit_log2 [lindex $bit_log2_range 0]} {$bit_log2 <= [lindex $bit_log2_range 1]}	{incr bit_log2}	{


				set tmp $results([list $free_running $edge_check $bit_log2])


				set luts	[lindex $tmp 0]
				set ffs		[lindex $tmp 1]
				set delay	[lindex $tmp 2]

				#set luts	[lindex $results($free_running $edge_check $bit_log2) 0]
				#set ffs		[lindex $results($free_running $edge_check $bit_log2) 1]
				#set delay	[lindex $results($free_running $edge_check $bit_log2) 2]

				append constant_array_record "\t\t\t\t"
				append constant_array_record "("
				append constant_array_record $luts
				append constant_array_record ","
				append constant_array_record $ffs
				append constant_array_record ","
				append constant_array_record $delay
				append constant_array_record ")"

				if {$bit_log2 < [lindex $bit_log2_range 1]} {
					append constant_array_record ","
				}

				append constant_array_record "\t--FREE_RUNNING = $free_running_boole,\tEDGE_CHECK = $edge_check_boole,\tBIT_LOG2 = $bit_log2\n"

			}

			append constant_array_record "\t\t\t)"
			if {$edge_check < [lindex $edge_check_range 1]} {
				append constant_array_record ",\n"
			} else {
				append constant_array_record "\n"
			}


		}

		append constant_array_record "\t\t)"
		if {$free_running < [lindex $free_running_range 1]} {
			append constant_array_record ",\n"
		} else {
			append constant_array_record "\n"
		}


	}

	append constant_array_record "\t);\n"

	return $constant_array_record
}
#-------------------------------------------------------------------------------

#===============================================================================


#======================== SYNTH ANALISYS PROCEDURE =============================
#-- Compute the LUTs FFs maxLogicCrossed max/min PathDelay with synth_design --
proc computeRecord_synth_design {free_running edge_check bit_log2} \
{

	#-------------------------- Synthesis Project Mode -------------------------

	# Set the New Generic set (for safety)
	set_property GENERIC	"FREE_RUNNING=1'b[expr $free_running] EDGE_CHECK=1'b[expr $edge_check] BIT_DATA=[expr 2**$bit_log2] BIT_LOG2=[expr $bit_log2]"	[current_fileset]

	# Open the Syntehesis for the results computation in Out Of Context withou buffers
	synth_design -mode out_of_context

	#---------------------------------------------------------------------------


	#------------------------------ Results ------------------------------------


	# Compute the Number of FFs and LUTs
	set	LUTs	[llength [get_cells -hierarchical -filter { PRIMITIVE_TYPE =~ CLB.LUT.* } ]]
	set	FFs		[llength [get_cells -hierarchical -filter { PRIMITIVE_TYPE =~ REGISTER.SDR.* } ]]

	# Initializate the Post-Synthesis timing analisys
	create_clock -period 10.000 -name clk_test_timing -waveform {0.000 5.000} [get_nets clk]

	# Identify the max and min propagation delay in nano seconds
	set	maxPathDelayNanoSec	[get_property DATAPATH_DELAY [get_timing_paths -setup ]]
	set	minPathDelayNanoSec	[get_property DATAPATH_DELAY [get_timing_paths -hold ]]

	# Set the number of logic crossed in from a FF to a FF
	if {$minPathDelayNanoSec == 0} {
		set maxLogicCrossed 1
	} else {
		set maxLogicCrossed [expr {int([expr {ceil($maxPathDelayNanoSec/$minPathDelayNanoSec)}])}]
	}

	# Save Results
	set results_synth [list $LUTs $FFs $maxLogicCrossed $maxPathDelayNanoSec $minPathDelayNanoSec]

	# Close the Post-Syntesis
	close_design
	#--------------------------------------------------------------------------

	return $results_synth

}
#-------------------------------------------------------------------------------


#-------- Compute the LUTs FFs maxLogicCrossed max/min PathDelay in run --------

proc computeRecord_launch_run {free_running edge_check bit_log2 regenerate_run} \
{

	#-------------------------- Synthesis Project Mode -------------------------
	set	synth_id	"synth_FR[expr $free_running]_EC[expr $edge_check]_BD[expr 2**$bit_log2]_BL[expr $bit_log2]"

	# Create and Run Specific Syntesis
	if {[get_runs $synth_id] != $synth_id} {

		# Create Synth Run
		create_run $synth_id -flow {Vivado Synthesis 2017}

		# Set the New Generic set
		set_property GENERIC	"FREE_RUNNING=1'b[expr $free_running] EDGE_CHECK=1'b[expr $edge_check] BIT_DATA=[expr 2**$bit_log2] BIT_LOG2=[expr $bit_log2]"	[current_fileset]

		# Launch the New Synthesis
		launch_runs	$synth_id	-jobs 6

		# Wait untill the Syntehesis is finished
		wait_on_run	$synth_id

	 # Open/Reset and ReRun an esisten Syntesis Rus
	} else {

		# Re Run only if request
		if { $regenerate_run == 1 } {

			# Reset Synth Run
			reset_run $synth_id

			# Set the New Generic set (for safety)
			set_property GENERIC	"FREE_RUNNING=1'b[expr $free_running] EDGE_CHECK=1'b[expr $edge_check] BIT_DATA=[expr 2**$bit_log2] BIT_LOG2=[expr $bit_log2]"	[current_fileset]

			# Launch the New Synthesis
			launch_runs	$synth_id	-jobs 6

			# Wait untill the Syntehesis is finished
			wait_on_run	$synth_id

		} else {

			open_run $synth_id -name $synth_id

		}
	}
	#---------------------------------------------------------------------------


	#------------------------------ Results ------------------------------------
	# Open the Syntehesis for the results computation in Out Of Context withou buffers
	synth_design -mode out_of_context

	# Compute the Number of FFs and LUTs
	set	LUTs	[llength [get_cells -hierarchical -filter { PRIMITIVE_TYPE =~ CLB.LUT.* } ]]
	set	FFs		[llength [get_cells -hierarchical -filter { PRIMITIVE_TYPE =~ REGISTER.SDR.* } ]]

	# Initializate the Post-Synthesis timing analisys
	create_clock -period 10.000 -name clk_test_timing -waveform {0.000 5.000} [get_nets clk]

	# Identify the max and min propagation delay in nano seconds
	set	maxPathDelayNanoSec	[get_property DATAPATH_DELAY [get_timing_paths -setup ]]
	set	minPathDelayNanoSec	[get_property DATAPATH_DELAY [get_timing_paths -hold ]]

	# Set the number of logic crossed in from a FF to a FF
	if {$minPathDelayNanoSec == 0} {
		set maxLogicCrossed 1
	} else {
		set maxLogicCrossed [expr {int([expr {ceil($maxPathDelayNanoSec/$minPathDelayNanoSec)}])}]
	}

	# Save Results
	set results_synth [list $LUTs $FFs $maxLogicCrossed $maxPathDelayNanoSec $minPathDelayNanoSec]

	# Close the Post-Syntesis
	close_design
	#--------------------------------------------------------------------------

	return $results_synth

}
#-------------------------------------------------------------------------------

#===============================================================================



#============================== USER DEFINED PROC ==============================

#------------------------------ int(ceil(a/b)) ----------------------------------

proc div_exc {a b} \
{

	set q [expr $a/$b]

	set r [expr $a%$b]

	if {$r != 0} {
		set q [expr $q+1]
	}

	return $q

}
#-------------------------------------------------------------------------------


#===============================================================================




#============================== LOG2DN SCRIPT INIT =============================

array set full_generic_array {}
unset full_generic_array

set total_cores 0

for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for {set edge_check 0} {$edge_check <= 1} {incr edge_check} {
		for	{set bit_log2 $MIN_BIT_LOG2} {$bit_log2 <= $MAX_BIT_LOG2} {incr bit_log2}	{

			set full_generic_array([list $free_running $edge_check $bit_log2]) [list $free_running $edge_check $bit_log2]

			incr total_cores

		}
	}
}


#----- test ------
# parray full_generic_array
# puts $total_cores
#-----------------


#-- Write Status --

# Set status
set 	file_txt "========== PRE-ANALISYS ==========\n"
append	file_txt "Total Cores \t$total_cores\n"
append 	file_txt "==================================\n\n"

# Set path
set		status_path	$status_location
append	status_path	"/"
append	status_path	$status_name
append	status_path	".txt"

# Open file_vhd for writing
set status_outputFile [open $status_path w]

# Put some text in to the file
puts $status_outputFile $file_txt

# Close the file
close $status_outputFile
#-----------------


#===============================================================================






#================================ LOG2DN SCRIPT ================================



#------------------- Change the Generic and compute results --------------------

array set results {}
unset results

set total_cores 0

for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for {set edge_check 0} {$edge_check <= 1} {incr edge_check} {
		for	{set bit_log2 $MIN_BIT_LOG2} {$bit_log2 <= $MAX_BIT_LOG2} {incr bit_log2}	{


			# set results([list $free_running $edge_check $bit_log2]) [computeRecord $free_running $edge_check $bit_log2 $REGENERATE_RUN]
			set results([list $free_running $edge_check $bit_log2]) [computeRecord_synth_design $free_running $edge_check $bit_log2]

			incr total_cores

			#-- Write Status --
			# Open file_vhd for writing
			set status_outputFile [open $status_path w]

			# Set status
			set		file_txt_tmp $file_txt
			append 	file_txt_tmp "========== EXE-ANALISYS ==========\n"
			append 	file_txt_tmp "Total\t$total_cores\n"
			append 	file_txt_tmp "==================================\n"


			# Put some text in to the file
			puts $status_outputFile $file_txt_tmp

			# Close the file
			close $status_outputFile
			#-----------------

		}
	}
}

#----- test ------
# parray results
#-----------------

#-------------------------------------------------------------------------------




#--- Find the min Propagation Delay For Better Extimation of maxLogicCrossed ---

# Find the min_propagation_delay in all the synth avaiable
set min_propagation_delay_list [list]
unset min_propagation_delay_list

for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for {set edge_check 0} {$edge_check <= 1} {incr edge_check} {
		for	{set bit_log2 $MIN_BIT_LOG2} {$bit_log2 <= $MAX_BIT_LOG2} {incr bit_log2}	{


			set min_propagation_delay_tmp	[ lindex $results([list $free_running $edge_check $bit_log2]]) 4]
			if {$min_propagation_delay_tmp > 0 } {

				lappend min_propagation_delay_list $min_propagation_delay_tmp

			}


		}
	}
}

# The min is the first not zero
set min_propagation_delay [lindex [ lsort $min_propagation_delay_list] 0]

# Redo the computation of the MaxLogicCrossed
for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for {set edge_check 0} {$edge_check <= 1} {incr edge_check} {
		for	{set bit_log2 $MIN_BIT_LOG2} {$bit_log2 <= $MAX_BIT_LOG2} {incr bit_log2}	{

			set index [list $free_running $edge_check $bit_log2]

			set		result_tmp [lindex $results($index) 0]
			lappend	result_tmp [lindex $results($index) 1]

			# Redo using the min_propagation_delay
			#lappend	result_tmp [lindex $results($index) 2]
			lappend	result_tmp [expr {int([expr {ceil([lindex $results($index) 3]/$min_propagation_delay)}])}]

			lappend	result_tmp [lindex $results($index) 3]
			lappend	result_tmp [lindex $results($index) 4]

			# Updatete Results with the new extimation
			set results($index) $result_tmp


		}
	}
}

#----- test ------
# parray results
#-----------------

#-------------------------------------------------------------------------------


# ---------------Transform array result in list results_list -------------------
set results_list [list]
unset results_list
for {set free_running 0} {$free_running <= 1} {incr free_running} {
	for {set edge_check 0} {$edge_check <= 1} {incr edge_check} {
		for	{set bit_log2 $MIN_BIT_LOG2} {$bit_log2 <= $MAX_BIT_LOG2} {incr bit_log2}	{


			# set results([list $free_running $edge_check $bit_log2]) [computeRecord $free_running $edge_check $bit_log2 $REGENERATE_RUN]
			lappend results_list $results([list $free_running $edge_check $bit_log2])

		}
	}
}

#----- test ------
# parray results_list
#-----------------

#-------------------------------------------------------------------------------


#----------------------------- Generate Package --------------------------------

# Constant Definition Section
set	constants_def [generate_constant_def $MIN_BIT_LOG2 $MAX_BIT_LOG2]

# Types (Record/Array) Definition Section
set record_def				[generate_record_def]
set array_record_def		[generate_array_record_def [list 0 1] [list 0 1] [list "MIN_BIT_LOG2" "MAX_BIT_LOG2"]]

set		types_def	$record_def
append	types_def	"\n"
append	types_def	$array_record_def


# Autocomputed Constants Section, LUTs, FFs, DELAY of Synth in ARRAY_RECORD
set constants_init	[generate_constant_array_record [list 0 1] [list 0 1] [list $MIN_BIT_LOG2 $MAX_BIT_LOG2] $results_list]

# Write package and body
set package [generate_package $package_name $constants_def $types_def $constants_init]
set body [generate_body $package_name]

# Write file vhd
set 	file_vhd	$header_1
append	file_vhd	"\n"
append	file_vhd	$header_2
append	file_vhd	"\n"
append	file_vhd	$description
append	file_vhd	"\n"
append	file_vhd	$default_library
append	file_vhd	"\n"
append	file_vhd	$others_library
append	file_vhd	"\n"
append	file_vhd	$package
append	file_vhd	"\n"
append	file_vhd	$body
#-------------------------------------------------------------------------------

#---------------------------- Write File Package -------------------------------
# Set path
set		package_path	$package_location
append	package_path	"/"
append	package_path	$package_name
append	package_path	".vhd"

# Open file_vhd for writing
set package_outputFile [open $package_path w]

# Put some text in to the file
puts $package_outputFile $file_vhd

# Close the file
close $package_outputFile
#-------------------------------------------------------------------------------

#===============================================================================
