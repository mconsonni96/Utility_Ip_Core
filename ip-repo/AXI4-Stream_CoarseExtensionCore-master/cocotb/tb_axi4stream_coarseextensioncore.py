# -------------------------------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------------------------------
# --                                                                                                                     --
# --  __/\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\__/\\\\\\\\\\\\_____/\\\\\\\\\\\__/\\\\\\\\\\\\\\\__/\\\_____________          --
# --   _\///////\\\/////__\/\\\///////////__\/\\\////////\\\__\/////\\\///__\/\\\///////////__\/\\\_____________         --
# --    _______\/\\\_______\/\\\_____________\/\\\______\//\\\_____\/\\\_____\/\\\_____________\/\\\_____________        --
# --     _______\/\\\_______\/\\\\\\\\\\\_____\/\\\_______\/\\\_____\/\\\_____\/\\\\\\\\\\\_____\/\\\_____________       --
# --      _______\/\\\_______\/\\\///////______\/\\\_______\/\\\_____\/\\\_____\/\\\///////______\/\\\_____________      --
# --       _______\/\\\_______\/\\\_____________\/\\\_______\/\\\_____\/\\\_____\/\\\_____________\/\\\_____________     --
# --        _______\/\\\_______\/\\\_____________\/\\\_______/\\\______\/\\\_____\/\\\_____________\/\\\_____________	 --
# --         _______\/\\\_______\/\\\\\\\\\\\\\\\_\/\\\\\\\\\\\\/____/\\\\\\\\\\\_\/\\\\\\\\\\\\\\\_\/\\\\\\\\\\\\\\\_   --
# --          _______\///________\///////////////__\////////////_____\///////////__\///////////////__\///////////////__  --
# --                                                                                                                     --
# -------------------------------------------------------------------------------------------------------------------------
# -------------------------------------------------------------------------------------------------------------------------

# ==============================================================================
# Debugger in CoCoTb of the CoarseExtensionCore Module with the following settings
#

# CEC_VS_CTD_COUNTER	:	STRING						:= "CEC";			-- CEC coarse counter generated by the internal CoarseExtensionCore, CTD coarse counter came from external CoarseTreeDistributor

# CEC_COARSE_CNT_INIT	:	NATURAL						:= 0;				-- Initialization Value of the Internal Coarse Counter in CoarseExtensionCore
# BIT_COARSE			:	POSITIVE	RANGE 1 TO 32	:= 8;				-- Bit Dimension of the Coarse part of the Timestamp

# INTERNAL_OVERFLOW_CNT	:	BOOLEAN		:=	TRUE;						--! Generic used for deciding whether to count the overflows in the CEC (if *INTERNAL_OVERFLOW_CNT* is TRUE) or leave the Overfow Counter the task of counting (if *INTERNAL_OVERFLOW_CNT* is FALSE)
#----------------------------------------------

#------------- Uncalibrated Dimension --------
#----- Uncalibrated -----
#BIT_SUB_INT			:	POSITIVE	RANGE	2	TO	16	:=	10;			-- Number of Bit of SubInterpolated TDL
#BIT_UNCALIBRATED	:	POSITIVE	RANGE	2	TO	16	:=	10;			-- Number of Bit of Uncalibrated_TDL (Default, Equal to BIT_SUB_INT)
#------------------------

#-------- BeltBus -------
#BIT_FID					:	NATURAL 	:=	1;							-- Function ID of the Belt Bus, 0 = OVERFLOW Coarse, 1 = MEASURE, If BIT_FID = 0 the belt bus is removed and it is a standard AXI4 stream
#------------------------
#----------------------------------------------

#--------------- xpm_fifo_async ---------------
#FIFO_MEMORY_TYPE	:	STRING							:=	"distributed";      		-- Type of FIFO; "auto", "block", or "distributed";
#RELATED_CLOCKS		:	BOOLEAN							:=	FALSE;						-- Specifies if the wr_clk (s00_uncalibTDC_aclk) and rd_clk (m00_uncalibSYS_aclk) are related, if 1 clk  and clk  are locked
#FIFO_WRITE_DEPTH	:	INTEGER	RANGE	16	TO	4194304	:=	128;           				-- FIFO Depth, Power of 2
#CDC_SYNC_STAGES		:	INTEGER	RANGE	2	TO	8		:=	4;							-- Cross Domain Clock Synch Stages: specifies the number of synchronization stages on the CDC path. It must be < 5 if *FIFO_WRITE_DEPTH = 16*
#----------------------------------------------
# ==============================================================================

#NB. EVERYTIME YOU CHANGE BIT_UNCALIBRATED AND FIFO_WRITE_DEPTH, YOU HAVE TO RICOMPILE THE XPM, SINCE THEY CHANGE THE FIFO WIDTH AND DEPTH RESPECTIVELY.
#BEFORE SIMULATING, LOOK AT THE ACTUAL DIMENSIONS OF THE COMPILED FIFO, IN ORDER NOT TO FACE STRANGE ERRORS (EX. unable to .... <U>). NOTICE THAT FOR SMALL VALUE OF FIFO_WRITE_DEPTH THERE COULD BE SOME
# WRONG VALUES IN THE TEST WRT THE DUT, SINCE THE FIFO GETS FULL AND IN THE DUT WE LOOSE SOME VALUES, BUT IN THE MODEL WE DON'T HAVE THE CONTROL OF WHEN THE FIFO GETS FULL. SO IT IS BETTER TO USE LARGE
# VALUES OF THE FIFO_WRITE_DEPTH.

#NB THE SIMULATION WORKS ONLY IF INTERNAL_OVERFLOW_CNT = TRUE, SINCE THE MODEL COUNTS THE OVERFLOWS

import random

import numpy as np

import cocotb
from cocotb.clock import Clock
from cocotb.decorators import coroutine
from cocotb.triggers import Timer, RisingEdge, ReadOnly, FallingEdge
from cocotb.monitors import Monitor
from cocotb.drivers import BitDriver
from cocotb.binary import BinaryValue
from cocotb.regression import TestFactory
from cocotb.scoreboard import Scoreboard
from cocotb.result import TestFailure, TestSuccess
from cocotb.utils import get_sim_time

from AxiStreamMaster import AxiStreamMaster, StreamBusMonitor



from enum import IntEnum

# =============================== My Enum ======================================
class id_value(IntEnum):
    """
    Class that define the enum MODEL_TRIG_VALID, model called by HDL valid=1 and MODEL_TRIG_OVERFLOW model called by HDL CoarseCounter_CTD overflow
    """
    MODEL_TRIG_VALID = 0
    MODEL_TRIG_OVERFLOW = 1

# ==============================================================================

# ========== Coarse Extension Core Input Driver (AXI Stram Master) =============
class CECInputDriver(AxiStreamMaster):
    """
    Class used for driving the Axis Master at the input of the Coarse Extension Core

    """

    def __init__(self, entity, name, clock, bit_sub_int ):
        """
            Initialization of CECInputDriver

            Args:
                entity: handle to the simulator entity
                name: Name of the bus
                clock: handle to the clk associated with this bus
        """
        AxiStreamMaster.__init__(self, entity, name, clock)

        self.bit_sub_int = bit_sub_int

    @cocotb.coroutine
    def deterministic_driver( self, subint_in, clk_delay):
        """Short summary.

        Parameters
        ----------
        subint_in : integer
            Value of the fine part to write in dut

        clk_delay : integer
            number of clk (-1) of total transaction
        """

        # Write
        yield self.write(subint_in)

        # Delay
        for I in range(clk_delay):
            yield RisingEdge(self.clock)




    @cocotb.coroutine
    def random_driver( self, switching_factor = 1):
        """
        Driver of the DUT Coarse Extension Core
        """
        while True:

            if np.random.random() < switching_factor:
                val_tmp = self.random_input_gen()
                yield self.write(val_tmp)
                # print('num:',cnt_tmp,'val:',val_tmp)

            else:
                yield RisingEdge(self.clock)


    def random_input_gen(self):
        """
        Input Code Generator of DUT
        1) np.random.randint(0,2,BIT_SUB_INT) is a binary array BIT_SUB_INT length as the fine Length
        2) convert (1) into string
        3) return a integer compatible with the AxiStreamMaster Object
        """

        def convert(list):
            """
            Convert a list into a string with between apex ''

            E.g.
            list = [1,2,3]
            return = '123'
            """

            # Converting integer list to string list
            s = [str(i) for i in list]

            # Join list items using join()
            res = int("".join(s))

            return(str(res))

        return int(convert(np.random.randint(0,2,self.bit_sub_int)),2)

# ==============================================================================


# ==================== Monitor of the Coarse Counter CTD =======================

class CounterMonitor(Monitor):

    """Observes the counter in input of DUT."""

    def __init__(self, name, signal, clock, bit_coarse, callback=None, event=None):
        self.name = name
        self.signal = signal
        self.clock = clock
        self.bit_coarse = bit_coarse
        Monitor.__init__(self, callback, event)

    @coroutine
    def _monitor_recv(self):
        clkedge = RisingEdge(self.clock)

        while True:
            # Capture signal at rising edge of clock
            yield clkedge
            yield ReadOnly()

            counter = self.signal.value.integer

            # Trigger at overflow
            if counter == 0:
                self._recv(int(counter))

# ==============================================================================


# ==============================================================================

class TestBenchDut(object):

    def __init__(self, dut, switching_factor, debug, coarse_couneter_init):
        """
        Initializzation of the Testbech of the DUT
        """

        # ----------------- Initialization ----------------
        # If Debug print on consolle
        self.debug = debug

        # Simulation Parameters, VHDL
        self.dut = dut
        self.clk_TDC = dut.clk_TDC
        self.clk_SYS = dut.clk_SYS
        self.reset_TDC = dut.reset_TDC
        self.reset_SYS = dut.reset_SYS
        self.tvalid = dut.s00_axis_subint_tvalid

        # Simulation Parameters, Generics
        self.bit_coarse = dut.BIT_COARSE.value.integer
        self.bit_sub_int = dut.BIT_SUB_INT.value.integer
        self.bit_uncalibrated = dut.BIT_UNCALIBRATED.value.integer
        self.bit_fid = dut.BIT_FID.value.integer

        # Monitoring full and reset ib the fifo
        self.wr_rst_busy = self.dut.inst_axi4stream_coarseextensioncore.inst_axi4stream_coarseextensioncorewrapper_cec.inst_coarseextensioncore.inst_fifo_synchronizer.inst_xpm_fifo_async.wr_rst_busy    #signal of the FIFO

        # Simulation Parameter, Data Generator
        self.switching_factor = switching_factor
        # -------------------------------------------------


        # ---------------- Input Driver ------------------
        # Drive the CoarseCounter_CTD
        cocotb.fork(self.CoarseCounterInputDriver(coarse_couneter_init))                            #coroutine used to generate the coarse counter CTD

        # AXIS Input s00_axis_subint Driver
        self.axis_input_drv = CECInputDriver(self.dut,"s00_axis_subint", self.clk_TDC , self.bit_sub_int)
        cocotb.fork(self.axis_input_drv.random_driver(self.switching_factor))
        # cocotb.fork(self.axis_input_drv.deterministic_driver(0, 10 )
        # -------------------------------------------------


        # ------------- AXIS Output Monitor -----------------
        self.axis_output_mon = StreamBusMonitor(self.dut, "m00_axis_uncalib", self.clk_SYS )
        # -------------------------------------------------

        # -------------------- Scoreboard --------------------
        self.expected_output = [ ]

        scoreboard_pnt = Scoreboard(dut, fail_immediately=False)
        scoreboard_pnt.add_interface(self.axis_output_mon, self.expected_output)
        # -------------------------------------------------

        # --------------- Model Initiualization -----------
        #output of the model
        self.overflow_count = 1                                                 #Initialization of the overflow counter, line 701 CoarseEztensinoCore.vhd
        self.uncalibrated_binary = np.binary_repr(0 , width = self.bit_uncalibrated)     #Initialization of what we write in the FIFO sized on bit_uncalibrated
        # -------------------------------------------------


        # --------------- Input Monitor -------------------
        # there is an IDENTIFICATOR, used by the model to recognize who is calling the model

        # AXIS Input sub_int input monitor
        self.axis_input_mon = StreamBusMonitor(self.dut, "s00_axis_subint", self.clk_TDC,  callback=lambda x : self.model(x, id_value.MODEL_TRIG_VALID))
        # CoarseCounter_CTD input monitor
        self.counter_mon = CounterMonitor("CoarseCounter_CTD", self.dut.CoarseCounter_CTD, self.clk_TDC , self.bit_coarse, callback=lambda x : self.model(x, id_value.MODEL_TRIG_OVERFLOW))
        # -------------------------------------------------


    #Coarse Counter CTD
    @cocotb.coroutine
    def CoarseCounterInputDriver(self, coarse_couneter_init):

        self.dut.CoarseCounter_CTD.value = coarse_couneter_init

        while True:

            yield RisingEdge(self.clk_TDC)
            self.dut.CoarseCounter_CTD.value = self.dut.CoarseCounter_CTD.value.integer + 1



    #NB with the model i don't manage the FIFO, so when it gets full, there can be some problems for the model
    def model(self, subint_in, ID):

        """Short summary.

        Parameters
        ----------
        subint_in : integer
            input of CEC, range from 0 to 2^bit_sub_int -1

        ID : integer
            IDENTIFICATOR, used by the model to recognize who is calling the model, if it is 1 it means that we are passing the counter only, if 0 we are passing the counter and the measure

		Returns at clk
        -------
        integer
            if overflow: bit_fid + overflow_count
            if no overflow: bit_fid + coarsecounter_CTD + subint_in
			but first we have to manage the bit dimension bit_sub_int/bit_uncalibrated
        """

        #  --- model called by s00_subint_tvalid = 1 ------
        if ID is id_value.MODEL_TRIG_VALID:

            #  Prepare Uncalibrated
            subint_binary = np.binary_repr(subint_in , width = self.bit_sub_int)

            #we take the MSBs of the subinterpolated data in the FIFO in case bit_sub_int > bit_uncalibrated
            if self.bit_sub_int > self.bit_uncalibrated:
                self.uncalibrated_binary = subint_binary[0  : (self.bit_uncalibrated)]

            #we put the subinterpolated data in the MSBs of the FIFO in case bit_sub_int < bit_uncalibrated
            if self.bit_sub_int < self.bit_uncalibrated:
                self.uncalibrated_binary = self.uncalibrated_binary.replace(self.uncalibrated_binary[0:self.bit_sub_int], subint_binary, 1)

            #we copy the subinterpolated data in the FIFO in case bit_sub_int = bit_uncalibrated
            if self.bit_sub_int == self.bit_uncalibrated:
                self.uncalibrated_binary = subint_binary

            # model
            if self.tvalid == 1:

                #in case we are reading data without overflow,
                # in output we send bit_fid = 1 the coarse and the fine...
                # we take care of the fact that we can write just when the wr_rst_busy signal is 0
                if self.dut.CoarseCounter_CTD.value.integer <= 2**self.bit_coarse - 1:

                    # Prepare data in output
                    data_out_binary = ['1' , np.binary_repr(self.dut.CoarseCounter_CTD.value.integer , width = self.bit_coarse) , self.uncalibrated_binary]
                    data_out_str = "".join(data_out_binary)
                    self.expected_output.append(int(data_out_str , 2))

                    # Print on consolle
                    if self.debug == True:
                        print("\n--- MODEL ---");
                        print("ID=", ID)
                        print("FID:\t1")
                        print("coarse:\t",self.dut.CoarseCounter_CTD.value)
                        print("fine:\t",self.uncalibrated_binary)
                        print("out:" , np.binary_repr(self.expected_output[-1]))
                        print("\n-------------")

                #in case we are reading data with overflow,
                # in output we send first bit_fid= 0 and the value of the overflow counter, and then we send bit_fid = 1 the coarse and the fine...
                # we take care of the fact that we can write just when the wr_rst_busy signal is 0
                elif self.dut.CoarseCounter_CTD.value.integer == 0:

                    # Prepare data (overflow) in output
                    data_out_binary = ['0' , np.binary_repr(self.overflow_count , width = self.bit_coarse + self.bit_uncalibrated) ]
                    data_out_str = "".join(data_out_binary)
                    self.expected_output.append(int(data_out_str ,2 ))

                    # Overflow update
                    self.overflow_count = self.overflow_count + 1

                    # Print on consolle
                    if self.debug == True:
                        print("\n--- MODEL ---");
                        print("ID=", ID)
                        print("FID:\t0")
                        print("overflow", self.overflow_count)
                        print("out:" , np.binary_repr(self.expected_output[-1]))
                        print("\n-------------")

                    # Prepare data (timestamp) in output
                    data_out_binary = ['1' , np.binary_repr(self.dut.CoarseCounter_CTD.value.integer , width = self.bit_coarse) , self.uncalibrated_binary]
                    data_out_str = "".join(data_out_binary)
                    self.expected_output.append(int(data_out_str,2))

                    # Print on consolle
                    if self.debug == True:
                        print("\n--- MODEL ---");
                        print("ID=", ID)
                        print("FID:\t1")
                        print("coarse:\t",self.dut.CoarseCounter_CTD.value)
                        print("fine:\t",self.uncalibrated_binary)
                        print("out:" , np.binary_repr(self.expected_output[-1]))
                        print("\n-------------")
        # -------------------------------------------------

        #  ------ model called by Counter in overflow ------
        if ID is id_value.MODEL_TRIG_OVERFLOW:

            #in case we are reading invalid data with overflow, in output we send bit_fid = 0 and the number of overflows
            if self.dut.CoarseCounter_CTD.value.integer == 0:

                # Prepare data (overflow) in output
                data_out_binary = ['0' , np.binary_repr(self.overflow_count , width = self.bit_coarse + self.bit_uncalibrated)]
                data_out_str = "".join(data_out_binary)
                self.expected_output.append(int(data_out_str,2))

                # Overflow update
                self.overflow_count = self.overflow_count + 1

                # Print on consolle
                if self.debug == True:
                    print("\n--- MODEL ---");
                    print("ID=", ID)
                    print("FID:\t0")
                    print("overflow", self.overflow_count)
                    print("out:" , np.binary_repr(self.expected_output[-1]))
                    print("\n-------------")
        # -------------------------------------------------

# ==============================================================================





@cocotb.test()

def main_test(dut):


    _SWITCHING_FACTOR = 0.007
    _SIM_TIME_NS = 2000

    # Set Clock at 10 ns
    clk_TDC  = dut.clk_TDC
    clk_SYS = dut.clk_SYS
    clock_pnt_TDC = Clock(clk_TDC , 2.4, units='ns')
    clock_pnt_SYS = Clock(clk_SYS , 10, units='ns')
    cocotb.fork(clock_pnt_TDC.start())
    cocotb.fork(clock_pnt_SYS.start())


    # Reset for 100 ns
    dut.reset_TDC <= 1
    dut.reset_SYS <= 1
    yield Timer(24, units='ns')

    dut.reset_TDC <= 0
    dut.reset_SYS <= 0



    # Monitoring full and reset ib the fifo
    wr_rst_busy_pnt = dut.inst_axi4stream_coarseextensioncore.inst_axi4stream_coarseextensioncorewrapper_cec.inst_coarseextensioncore.inst_fifo_synchronizer.inst_xpm_fifo_async.wr_rst_busy    #signal of the FIFO
    # Wait fifo rearm befor start
    yield FallingEdge(wr_rst_busy_pnt)


    tb = TestBenchDut(dut, _SWITCHING_FACTOR, True, 2)




    yield Timer(_SIM_TIME_NS, units = 'ns')
